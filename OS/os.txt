
build/os.elf:     file format elf32-littleriscv


Disassembly of section .text:

80000000 <_start>:
	.global	_start

	.text
_start:
	# park harts with id != 0
	csrr	t0, mhartid		# read current hart id
80000000:	f14022f3          	csrr	t0,mhartid
	mv	tp, t0			# keep CPU's hartid in its tp for later usage.
80000004:	00028213          	mv	tp,t0
	bnez	t0, park		# if we're not on the hart 0
80000008:	04029663          	bnez	t0,80000054 <park>
					# we park the hart

	# Set all bytes in the BSS section to zero.
	la	a0, _bss_start
8000000c:	00006517          	auipc	a0,0x6
80000010:	05450513          	addi	a0,a0,84 # 80006060 <timers>
	la	a1, _bss_end
80000014:	00c07597          	auipc	a1,0xc07
80000018:	af458593          	addi	a1,a1,-1292 # 80c06b08 <_bss_end>
	bgeu	a0, a1, 2f
8000001c:	00b57863          	bgeu	a0,a1,8000002c <_start+0x2c>
1:
	sw	zero, (a0)
80000020:	00052023          	sw	zero,0(a0)
	addi	a0, a0, 4
80000024:	00450513          	addi	a0,a0,4
	bltu	a0, a1, 1b
80000028:	feb56ce3          	bltu	a0,a1,80000020 <_start+0x20>
2:
	# Setup stacks, the stack grows from bottom to top, so we put the
	# stack pointer to the very end of the stack range.
	slli	t0, t0, 10		# shift left the hart id by 1024
8000002c:	00a29293          	slli	t0,t0,0xa
	la	sp, stacks + STACK_SIZE	# set the initial stack pointer
80000030:	00000117          	auipc	sp,0x0
80000034:	43010113          	addi	sp,sp,1072 # 80000460 <stacks+0x400>
					# to the end of the first stack space
	add	sp, sp, t0		# move the current hart stack pointer
80000038:	00510133          	add	sp,sp,t0
	# At the end of start_kernel, schedule() will call MRET to switch
	# to the first task, so we parepare the mstatus here.
	# Notice: default mstatus is 0
	# Set mstatus.MPP to 3, so we still run in Machine mode after MRET.
	# Set mstatus.MPIE to 1, so MRET will enable the interrupt.
	li	t0, 3 << 11 | 1 << 7
8000003c:	000022b7          	lui	t0,0x2
80000040:	88028293          	addi	t0,t0,-1920 # 1880 <STACK_SIZE+0x1480>
	csrr	a1, mstatus
80000044:	300025f3          	csrr	a1,mstatus
	or	t0, t0, a1
80000048:	00b2e2b3          	or	t0,t0,a1
	csrw	mstatus, t0
8000004c:	30029073          	csrw	mstatus,t0

	j	start_kernel		# hart 0 jump to c
80000050:	1e00206f          	j	80002230 <start_kernel>

80000054 <park>:

park:
	wfi
80000054:	10500073          	wfi
	j	park
80000058:	ffdff06f          	j	80000054 <park>
8000005c:	00000013          	nop

80000060 <stacks>:
	...

80002068 <trap_vector>:
.globl trap_vector
# the trap vector base address must always be aligned on a 4-byte boundary
.balign 4
trap_vector:
	# save context(registers).
	csrrw	t6, mscratch, t6	# swap t6 and mscratch
80002068:	340f9ff3          	csrrw	t6,mscratch,t6
	reg_save t6
8000206c:	001fa023          	sw	ra,0(t6)
80002070:	002fa223          	sw	sp,4(t6)
80002074:	005fa823          	sw	t0,16(t6)
80002078:	006faa23          	sw	t1,20(t6)
8000207c:	007fac23          	sw	t2,24(t6)
80002080:	008fae23          	sw	s0,28(t6)
80002084:	029fa023          	sw	s1,32(t6)
80002088:	02afa223          	sw	a0,36(t6)
8000208c:	02bfa423          	sw	a1,40(t6)
80002090:	02cfa623          	sw	a2,44(t6)
80002094:	02dfa823          	sw	a3,48(t6)
80002098:	02efaa23          	sw	a4,52(t6)
8000209c:	02ffac23          	sw	a5,56(t6)
800020a0:	030fae23          	sw	a6,60(t6)
800020a4:	051fa023          	sw	a7,64(t6)
800020a8:	052fa223          	sw	s2,68(t6)
800020ac:	053fa423          	sw	s3,72(t6)
800020b0:	054fa623          	sw	s4,76(t6)
800020b4:	055fa823          	sw	s5,80(t6)
800020b8:	056faa23          	sw	s6,84(t6)
800020bc:	057fac23          	sw	s7,88(t6)
800020c0:	058fae23          	sw	s8,92(t6)
800020c4:	079fa023          	sw	s9,96(t6)
800020c8:	07afa223          	sw	s10,100(t6)
800020cc:	07bfa423          	sw	s11,104(t6)
800020d0:	07cfa623          	sw	t3,108(t6)
800020d4:	07dfa823          	sw	t4,112(t6)
800020d8:	07efaa23          	sw	t5,116(t6)

	# Save the actual t6 register, which we swapped into
	# mscratch
	mv	t5, t6		# t5 points to the context of current task
800020dc:	000f8f13          	mv	t5,t6
	csrr	t6, mscratch	# read t6 back from mscratch
800020e0:	34002ff3          	csrr	t6,mscratch
	sw	t6, 120(t5)	# save t6 with t5 as base
800020e4:	07ff2c23          	sw	t6,120(t5)

	# save mepc to context of current task
	csrr	a0, mepc
800020e8:	34102573          	csrr	a0,mepc
	sw	a0, 124(t5)
800020ec:	06af2e23          	sw	a0,124(t5)

	# Restore the context pointer into mscratch
	csrw	mscratch, t5
800020f0:	340f1073          	csrw	mscratch,t5

	# call the C trap handler in trap.c
	csrr	a0, mepc
800020f4:	34102573          	csrr	a0,mepc
	csrr	a1, mcause
800020f8:	342025f3          	csrr	a1,mcause
	call	trap_handler
800020fc:	000010ef          	jal	ra,800030fc <trap_handler>

	# trap_handler will return the return address via a0.
	csrw	mepc, a0
80002100:	34151073          	csrw	mepc,a0

	# restore context(registers).
	csrr	t6, mscratch
80002104:	34002ff3          	csrr	t6,mscratch
	reg_restore t6
80002108:	000fa083          	lw	ra,0(t6)
8000210c:	004fa103          	lw	sp,4(t6)
80002110:	010fa283          	lw	t0,16(t6)
80002114:	014fa303          	lw	t1,20(t6)
80002118:	018fa383          	lw	t2,24(t6)
8000211c:	01cfa403          	lw	s0,28(t6)
80002120:	020fa483          	lw	s1,32(t6)
80002124:	024fa503          	lw	a0,36(t6)
80002128:	028fa583          	lw	a1,40(t6)
8000212c:	02cfa603          	lw	a2,44(t6)
80002130:	030fa683          	lw	a3,48(t6)
80002134:	034fa703          	lw	a4,52(t6)
80002138:	038fa783          	lw	a5,56(t6)
8000213c:	03cfa803          	lw	a6,60(t6)
80002140:	040fa883          	lw	a7,64(t6)
80002144:	044fa903          	lw	s2,68(t6)
80002148:	048fa983          	lw	s3,72(t6)
8000214c:	04cfaa03          	lw	s4,76(t6)
80002150:	050faa83          	lw	s5,80(t6)
80002154:	054fab03          	lw	s6,84(t6)
80002158:	058fab83          	lw	s7,88(t6)
8000215c:	05cfac03          	lw	s8,92(t6)
80002160:	060fac83          	lw	s9,96(t6)
80002164:	064fad03          	lw	s10,100(t6)
80002168:	068fad83          	lw	s11,104(t6)
8000216c:	06cfae03          	lw	t3,108(t6)
80002170:	070fae83          	lw	t4,112(t6)
80002174:	074faf03          	lw	t5,116(t6)
80002178:	078faf83          	lw	t6,120(t6)

	# return to whatever we were doing before trap.
	mret
8000217c:	30200073          	mret

80002180 <switch_to>:
# a0: pointer to the context of the next task
.globl switch_to
.balign 4
switch_to:
	# switch mscratch to point to the context of the next task
	csrw	mscratch, a0
80002180:	34051073          	csrw	mscratch,a0
	# set mepc to the pc of the next task
	lw	a1, 124(a0)
80002184:	07c52583          	lw	a1,124(a0)
	csrw	mepc, a1
80002188:	34159073          	csrw	mepc,a1

	# Restore all GP registers
	# Use t6 to point to the context of the new task
	mv	t6, a0
8000218c:	00050f93          	mv	t6,a0
	reg_restore t6
80002190:	000fa083          	lw	ra,0(t6)
80002194:	004fa103          	lw	sp,4(t6)
80002198:	010fa283          	lw	t0,16(t6)
8000219c:	014fa303          	lw	t1,20(t6)
800021a0:	018fa383          	lw	t2,24(t6)
800021a4:	01cfa403          	lw	s0,28(t6)
800021a8:	020fa483          	lw	s1,32(t6)
800021ac:	024fa503          	lw	a0,36(t6)
800021b0:	028fa583          	lw	a1,40(t6)
800021b4:	02cfa603          	lw	a2,44(t6)
800021b8:	030fa683          	lw	a3,48(t6)
800021bc:	034fa703          	lw	a4,52(t6)
800021c0:	038fa783          	lw	a5,56(t6)
800021c4:	03cfa803          	lw	a6,60(t6)
800021c8:	040fa883          	lw	a7,64(t6)
800021cc:	044fa903          	lw	s2,68(t6)
800021d0:	048fa983          	lw	s3,72(t6)
800021d4:	04cfaa03          	lw	s4,76(t6)
800021d8:	050faa83          	lw	s5,80(t6)
800021dc:	054fab03          	lw	s6,84(t6)
800021e0:	058fab83          	lw	s7,88(t6)
800021e4:	05cfac03          	lw	s8,92(t6)
800021e8:	060fac83          	lw	s9,96(t6)
800021ec:	064fad03          	lw	s10,100(t6)
800021f0:	068fad83          	lw	s11,104(t6)
800021f4:	06cfae03          	lw	t3,108(t6)
800021f8:	070fae83          	lw	t4,112(t6)
800021fc:	074faf03          	lw	t5,116(t6)
80002200:	078faf83          	lw	t6,120(t6)

	# Do actual context switching.
	# Notice this will enable global interrupt
	mret
80002204:	30200073          	mret

80002208 <r_mhartid>:
	return x;
}

/* which hart (core) is this? */
static inline reg_t r_mhartid()
{
80002208:	fe010113          	addi	sp,sp,-32
8000220c:	00812e23          	sw	s0,28(sp)
80002210:	02010413          	addi	s0,sp,32
	reg_t x;
	asm volatile("csrr %0, mhartid" : "=r" (x) );
80002214:	f14027f3          	csrr	a5,mhartid
80002218:	fef42623          	sw	a5,-20(s0)
	return x;
8000221c:	fec42783          	lw	a5,-20(s0)
}
80002220:	00078513          	mv	a0,a5
80002224:	01c12403          	lw	s0,28(sp)
80002228:	02010113          	addi	sp,sp,32
8000222c:	00008067          	ret

80002230 <start_kernel>:
extern void trap_init(void);
extern void plic_init(void);
extern void timer_init(void);

void start_kernel(void)
{
80002230:	fe010113          	addi	sp,sp,-32
80002234:	00112e23          	sw	ra,28(sp)
80002238:	00812c23          	sw	s0,24(sp)
8000223c:	02010413          	addi	s0,sp,32
    uart_init();
80002240:	5f9010ef          	jal	ra,80004038 <uart_init>
    uart_puts("Hello, RVOS!\n");
80002244:	800057b7          	lui	a5,0x80005
80002248:	68878513          	addi	a0,a5,1672 # 80005688 <_memory_end+0xf8005688>
8000224c:	6bd010ef          	jal	ra,80004108 <uart_puts>

    page_init();
80002250:	24c010ef          	jal	ra,8000349c <page_init>

    trap_init();
80002254:	60d000ef          	jal	ra,80003060 <trap_init>

    plic_init();
80002258:	06c020ef          	jal	ra,800042c4 <plic_init>

    timer_init();
8000225c:	2f0020ef          	jal	ra,8000454c <timer_init>

    sched_init();
80002260:	13c000ef          	jal	ra,8000239c <sched_init>

    memory_init(); // 初始化内存管理
80002264:	6e4010ef          	jal	ra,80003948 <memory_init>

    os_main();
80002268:	16c030ef          	jal	ra,800053d4 <os_main>

    while (1)
    {
        SCHEDULE
8000226c:	f9dff0ef          	jal	ra,80002208 <r_mhartid>
80002270:	00050793          	mv	a5,a0
80002274:	fef42623          	sw	a5,-20(s0)
80002278:	fec42703          	lw	a4,-20(s0)
8000227c:	008007b7          	lui	a5,0x800
80002280:	00f707b3          	add	a5,a4,a5
80002284:	00279793          	slli	a5,a5,0x2
80002288:	00078713          	mv	a4,a5
8000228c:	00100793          	li	a5,1
80002290:	00f72023          	sw	a5,0(a4)
80002294:	fd9ff06f          	j	8000226c <start_kernel+0x3c>

80002298 <r_mhartid>:
{
80002298:	fe010113          	addi	sp,sp,-32
8000229c:	00812e23          	sw	s0,28(sp)
800022a0:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mhartid" : "=r" (x) );
800022a4:	f14027f3          	csrr	a5,mhartid
800022a8:	fef42623          	sw	a5,-20(s0)
	return x;
800022ac:	fec42783          	lw	a5,-20(s0)
}
800022b0:	00078513          	mv	a0,a5
800022b4:	01c12403          	lw	s0,28(sp)
800022b8:	02010113          	addi	sp,sp,32
800022bc:	00008067          	ret

800022c0 <r_mstatus>:
#define MSTATUS_MIE (1 << 3)
#define MSTATUS_SIE (1 << 1)
#define MSTATUS_UIE (1 << 0)

static inline reg_t r_mstatus()
{
800022c0:	fe010113          	addi	sp,sp,-32
800022c4:	00812e23          	sw	s0,28(sp)
800022c8:	02010413          	addi	s0,sp,32
	reg_t x;
	asm volatile("csrr %0, mstatus" : "=r" (x) );
800022cc:	300027f3          	csrr	a5,mstatus
800022d0:	fef42623          	sw	a5,-20(s0)
	return x;
800022d4:	fec42783          	lw	a5,-20(s0)
}
800022d8:	00078513          	mv	a0,a5
800022dc:	01c12403          	lw	s0,28(sp)
800022e0:	02010113          	addi	sp,sp,32
800022e4:	00008067          	ret

800022e8 <w_mscratch>:
	return x;
}

/* Machine Scratch register, for early trap handler */
static inline void w_mscratch(reg_t x)
{
800022e8:	fe010113          	addi	sp,sp,-32
800022ec:	00812e23          	sw	s0,28(sp)
800022f0:	02010413          	addi	s0,sp,32
800022f4:	fea42623          	sw	a0,-20(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
800022f8:	fec42783          	lw	a5,-20(s0)
800022fc:	34079073          	csrw	mscratch,a5
}
80002300:	00000013          	nop
80002304:	01c12403          	lw	s0,28(sp)
80002308:	02010113          	addi	sp,sp,32
8000230c:	00008067          	ret

80002310 <r_mie>:
#define MIE_MEIE (1 << 11) // external
#define MIE_MTIE (1 << 7)  // timer
#define MIE_MSIE (1 << 3)  // software

static inline reg_t r_mie()
{
80002310:	fe010113          	addi	sp,sp,-32
80002314:	00812e23          	sw	s0,28(sp)
80002318:	02010413          	addi	s0,sp,32
	reg_t x;
	asm volatile("csrr %0, mie" : "=r" (x) );
8000231c:	304027f3          	csrr	a5,mie
80002320:	fef42623          	sw	a5,-20(s0)
	return x;
80002324:	fec42783          	lw	a5,-20(s0)
}
80002328:	00078513          	mv	a0,a5
8000232c:	01c12403          	lw	s0,28(sp)
80002330:	02010113          	addi	sp,sp,32
80002334:	00008067          	ret

80002338 <w_mie>:

static inline void w_mie(reg_t x)
{
80002338:	fe010113          	addi	sp,sp,-32
8000233c:	00812e23          	sw	s0,28(sp)
80002340:	02010413          	addi	s0,sp,32
80002344:	fea42623          	sw	a0,-20(s0)
	asm volatile("csrw mie, %0" : : "r" (x));
80002348:	fec42783          	lw	a5,-20(s0)
8000234c:	30479073          	csrw	mie,a5
}
80002350:	00000013          	nop
80002354:	01c12403          	lw	s0,28(sp)
80002358:	02010113          	addi	sp,sp,32
8000235c:	00008067          	ret

80002360 <kernel_scheduler>:
 */
static int _top = 0;
int _current = -1;

void kernel_scheduler()
{
80002360:	fe010113          	addi	sp,sp,-32
80002364:	00112e23          	sw	ra,28(sp)
80002368:	00812c23          	sw	s0,24(sp)
8000236c:	02010413          	addi	s0,sp,32
	while (1)
	{
		SCHEDULE
80002370:	f29ff0ef          	jal	ra,80002298 <r_mhartid>
80002374:	00050793          	mv	a5,a0
80002378:	fef42623          	sw	a5,-20(s0)
8000237c:	fec42703          	lw	a4,-20(s0)
80002380:	008007b7          	lui	a5,0x800
80002384:	00f707b3          	add	a5,a4,a5
80002388:	00279793          	slli	a5,a5,0x2
8000238c:	00078713          	mv	a4,a5
80002390:	00100793          	li	a5,1
80002394:	00f72023          	sw	a5,0(a4)
80002398:	fd9ff06f          	j	80002370 <kernel_scheduler+0x10>

8000239c <sched_init>:
	}
}

// 在 `sched_init` 中创建内核调度任务
void sched_init()
{
8000239c:	ff010113          	addi	sp,sp,-16
800023a0:	00112623          	sw	ra,12(sp)
800023a4:	00812423          	sw	s0,8(sp)
800023a8:	01010413          	addi	s0,sp,16
	w_mscratch((reg_t)&kernel_ctx);
800023ac:	80b067b7          	lui	a5,0x80b06
800023b0:	68878793          	addi	a5,a5,1672 # 80b06688 <_memory_end+0xf8b06688>
800023b4:	00078513          	mv	a0,a5
800023b8:	f31ff0ef          	jal	ra,800022e8 <w_mscratch>
	w_mie(r_mie() | MIE_MSIE);
800023bc:	f55ff0ef          	jal	ra,80002310 <r_mie>
800023c0:	00050793          	mv	a5,a0
800023c4:	0087e793          	ori	a5,a5,8
800023c8:	00078513          	mv	a0,a5
800023cc:	f6dff0ef          	jal	ra,80002338 <w_mie>

	// 初始化内核调度任务上下文
	kernel_ctx.sp = (reg_t)&kernel_stack_kernel[KERNEL_STACK_SIZE];
800023d0:	80b067b7          	lui	a5,0x80b06
800023d4:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800023d8:	80b067b7          	lui	a5,0x80b06
800023dc:	68878793          	addi	a5,a5,1672 # 80b06688 <_memory_end+0xf8b06688>
800023e0:	00e7a223          	sw	a4,4(a5)
	kernel_ctx.pc = (reg_t)kernel_scheduler;
800023e4:	800027b7          	lui	a5,0x80002
800023e8:	36078713          	addi	a4,a5,864 # 80002360 <_memory_end+0xf8002360>
800023ec:	80b067b7          	lui	a5,0x80b06
800023f0:	68878793          	addi	a5,a5,1672 # 80b06688 <_memory_end+0xf8b06688>
800023f4:	06e7ae23          	sw	a4,124(a5)

	// task_create(kernel_scheduler, NULL, 0); // 优先级最高的内核任务

	// 其他初始化代码...
}
800023f8:	00000013          	nop
800023fc:	00c12083          	lw	ra,12(sp)
80002400:	00812403          	lw	s0,8(sp)
80002404:	01010113          	addi	sp,sp,16
80002408:	00008067          	ret

8000240c <back_to_os>:
void back_to_os(void)
{
8000240c:	ff010113          	addi	sp,sp,-16
80002410:	00112623          	sw	ra,12(sp)
80002414:	00812423          	sw	s0,8(sp)
80002418:	01010413          	addi	s0,sp,16
	switch_to(&kernel_ctx);
8000241c:	80b067b7          	lui	a5,0x80b06
80002420:	68878513          	addi	a0,a5,1672 # 80b06688 <_memory_end+0xf8b06688>
80002424:	d5dff0ef          	jal	ra,80002180 <switch_to>
}
80002428:	00000013          	nop
8000242c:	00c12083          	lw	ra,12(sp)
80002430:	00812403          	lw	s0,8(sp)
80002434:	01010113          	addi	sp,sp,16
80002438:	00008067          	ret

8000243c <is_user_mode>:

int is_user_mode(void)
{
8000243c:	fe010113          	addi	sp,sp,-32
80002440:	00112e23          	sw	ra,28(sp)
80002444:	00812c23          	sw	s0,24(sp)
80002448:	02010413          	addi	s0,sp,32
	reg_t mstatus = r_mstatus();
8000244c:	e75ff0ef          	jal	ra,800022c0 <r_mstatus>
80002450:	fea42623          	sw	a0,-20(s0)
	// 检查是否在用户模式中(ecall上下文)
	// 如果是ecall处理，当前处于机器模式，但返回特权级是用户模式
	return ((mstatus & MSTATUS_MPP) == 0);
80002454:	fec42703          	lw	a4,-20(s0)
80002458:	000027b7          	lui	a5,0x2
8000245c:	80078793          	addi	a5,a5,-2048 # 1800 <STACK_SIZE+0x1400>
80002460:	00f777b3          	and	a5,a4,a5
80002464:	0017b793          	seqz	a5,a5
80002468:	0ff7f793          	andi	a5,a5,255
}
8000246c:	00078513          	mv	a0,a5
80002470:	01c12083          	lw	ra,28(sp)
80002474:	01812403          	lw	s0,24(sp)
80002478:	02010113          	addi	sp,sp,32
8000247c:	00008067          	ret

80002480 <schedule>:

/*
 * implement a priority-based scheduler
 */
void schedule()
{
80002480:	fd010113          	addi	sp,sp,-48
80002484:	02112623          	sw	ra,44(sp)
80002488:	02812423          	sw	s0,40(sp)
8000248c:	03010413          	addi	s0,sp,48
	spin_lock();
80002490:	66d000ef          	jal	ra,800032fc <spin_lock>
	if (_top <= 0)
80002494:	80b067b7          	lui	a5,0x80b06
80002498:	70c7a783          	lw	a5,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
8000249c:	00f04663          	bgtz	a5,800024a8 <schedule+0x28>
	{
		spin_unlock();
800024a0:	699000ef          	jal	ra,80003338 <spin_unlock>
		return;
800024a4:	2780006f          	j	8000271c <schedule+0x29c>
	}

	int next_task = -1;
800024a8:	fff00793          	li	a5,-1
800024ac:	fef42623          	sw	a5,-20(s0)
	uint8_t highest_priority = 255;
800024b0:	fff00793          	li	a5,-1
800024b4:	fef405a3          	sb	a5,-21(s0)
	if (tasks[_current].state == TASK_RUNNING)
800024b8:	800067b7          	lui	a5,0x80006
800024bc:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
800024c0:	80b067b7          	lui	a5,0x80b06
800024c4:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800024c8:	09c00793          	li	a5,156
800024cc:	02f687b3          	mul	a5,a3,a5
800024d0:	00f707b3          	add	a5,a4,a5
800024d4:	0907a703          	lw	a4,144(a5)
800024d8:	00200793          	li	a5,2
800024dc:	02f71463          	bne	a4,a5,80002504 <schedule+0x84>
		tasks[_current].state = TASK_READY;
800024e0:	800067b7          	lui	a5,0x80006
800024e4:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
800024e8:	80b067b7          	lui	a5,0x80b06
800024ec:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800024f0:	09c00793          	li	a5,156
800024f4:	02f687b3          	mul	a5,a3,a5
800024f8:	00f707b3          	add	a5,a4,a5
800024fc:	00100713          	li	a4,1
80002500:	08e7a823          	sw	a4,144(a5)

	// 找到最高优先级
	for (int i = 0; i < _top; i++)
80002504:	fe042223          	sw	zero,-28(s0)
80002508:	0780006f          	j	80002580 <schedule+0x100>
	{
		if (tasks[i].state == TASK_READY && tasks[i].priority < highest_priority)
8000250c:	80b067b7          	lui	a5,0x80b06
80002510:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002514:	fe442683          	lw	a3,-28(s0)
80002518:	09c00793          	li	a5,156
8000251c:	02f687b3          	mul	a5,a3,a5
80002520:	00f707b3          	add	a5,a4,a5
80002524:	0907a703          	lw	a4,144(a5)
80002528:	00100793          	li	a5,1
8000252c:	04f71463          	bne	a4,a5,80002574 <schedule+0xf4>
80002530:	80b067b7          	lui	a5,0x80b06
80002534:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002538:	fe442683          	lw	a3,-28(s0)
8000253c:	09c00793          	li	a5,156
80002540:	02f687b3          	mul	a5,a3,a5
80002544:	00f707b3          	add	a5,a4,a5
80002548:	08c7c783          	lbu	a5,140(a5)
8000254c:	feb44703          	lbu	a4,-21(s0)
80002550:	02e7f263          	bgeu	a5,a4,80002574 <schedule+0xf4>
		{
			highest_priority = tasks[i].priority;
80002554:	80b067b7          	lui	a5,0x80b06
80002558:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
8000255c:	fe442683          	lw	a3,-28(s0)
80002560:	09c00793          	li	a5,156
80002564:	02f687b3          	mul	a5,a3,a5
80002568:	00f707b3          	add	a5,a4,a5
8000256c:	08c7c783          	lbu	a5,140(a5)
80002570:	fef405a3          	sb	a5,-21(s0)
	for (int i = 0; i < _top; i++)
80002574:	fe442783          	lw	a5,-28(s0)
80002578:	00178793          	addi	a5,a5,1
8000257c:	fef42223          	sw	a5,-28(s0)
80002580:	80b067b7          	lui	a5,0x80b06
80002584:	70c7a783          	lw	a5,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
80002588:	fe442703          	lw	a4,-28(s0)
8000258c:	f8f740e3          	blt	a4,a5,8000250c <schedule+0x8c>
		}
	}

	// 在最高优先级中轮转选择下一个任务
	for (int i = 0; i < _top; i++)
80002590:	fe042023          	sw	zero,-32(s0)
80002594:	0880006f          	j	8000261c <schedule+0x19c>
	{
		int idx = (_current + 1 + i) % _top;
80002598:	800067b7          	lui	a5,0x80006
8000259c:	0007a783          	lw	a5,0(a5) # 80006000 <_memory_end+0xf8006000>
800025a0:	00178713          	addi	a4,a5,1
800025a4:	fe042783          	lw	a5,-32(s0)
800025a8:	00f70733          	add	a4,a4,a5
800025ac:	80b067b7          	lui	a5,0x80b06
800025b0:	70c7a783          	lw	a5,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
800025b4:	02f767b3          	rem	a5,a4,a5
800025b8:	fcf42c23          	sw	a5,-40(s0)
		if (tasks[idx].state == TASK_READY && tasks[idx].priority == highest_priority)
800025bc:	80b067b7          	lui	a5,0x80b06
800025c0:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800025c4:	fd842683          	lw	a3,-40(s0)
800025c8:	09c00793          	li	a5,156
800025cc:	02f687b3          	mul	a5,a3,a5
800025d0:	00f707b3          	add	a5,a4,a5
800025d4:	0907a703          	lw	a4,144(a5)
800025d8:	00100793          	li	a5,1
800025dc:	02f71a63          	bne	a4,a5,80002610 <schedule+0x190>
800025e0:	80b067b7          	lui	a5,0x80b06
800025e4:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800025e8:	fd842683          	lw	a3,-40(s0)
800025ec:	09c00793          	li	a5,156
800025f0:	02f687b3          	mul	a5,a3,a5
800025f4:	00f707b3          	add	a5,a4,a5
800025f8:	08c7c783          	lbu	a5,140(a5)
800025fc:	feb44703          	lbu	a4,-21(s0)
80002600:	00f71863          	bne	a4,a5,80002610 <schedule+0x190>
		{
			next_task = idx;
80002604:	fd842783          	lw	a5,-40(s0)
80002608:	fef42623          	sw	a5,-20(s0)
			break;
8000260c:	0200006f          	j	8000262c <schedule+0x1ac>
	for (int i = 0; i < _top; i++)
80002610:	fe042783          	lw	a5,-32(s0)
80002614:	00178793          	addi	a5,a5,1
80002618:	fef42023          	sw	a5,-32(s0)
8000261c:	80b067b7          	lui	a5,0x80b06
80002620:	70c7a783          	lw	a5,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
80002624:	fe042703          	lw	a4,-32(s0)
80002628:	f6f748e3          	blt	a4,a5,80002598 <schedule+0x118>
		}
	}

	if (next_task == -1)
8000262c:	fec42703          	lw	a4,-20(s0)
80002630:	fff00793          	li	a5,-1
80002634:	06f71c63          	bne	a4,a5,800026ac <schedule+0x22c>
	{
		for (int i = 0; i < MAX_TASKS; i++)
80002638:	fc042e23          	sw	zero,-36(s0)
8000263c:	0640006f          	j	800026a0 <schedule+0x220>
		{
			if (tasks[i].state == TASK_READY && tasks[i].priority == highest_priority)
80002640:	80b067b7          	lui	a5,0x80b06
80002644:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002648:	fdc42683          	lw	a3,-36(s0)
8000264c:	09c00793          	li	a5,156
80002650:	02f687b3          	mul	a5,a3,a5
80002654:	00f707b3          	add	a5,a4,a5
80002658:	0907a703          	lw	a4,144(a5)
8000265c:	00100793          	li	a5,1
80002660:	02f71a63          	bne	a4,a5,80002694 <schedule+0x214>
80002664:	80b067b7          	lui	a5,0x80b06
80002668:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
8000266c:	fdc42683          	lw	a3,-36(s0)
80002670:	09c00793          	li	a5,156
80002674:	02f687b3          	mul	a5,a3,a5
80002678:	00f707b3          	add	a5,a4,a5
8000267c:	08c7c783          	lbu	a5,140(a5)
80002680:	feb44703          	lbu	a4,-21(s0)
80002684:	00f71863          	bne	a4,a5,80002694 <schedule+0x214>
			{
				next_task = i;
80002688:	fdc42783          	lw	a5,-36(s0)
8000268c:	fef42623          	sw	a5,-20(s0)
				break;
80002690:	01c0006f          	j	800026ac <schedule+0x22c>
		for (int i = 0; i < MAX_TASKS; i++)
80002694:	fdc42783          	lw	a5,-36(s0)
80002698:	00178793          	addi	a5,a5,1
8000269c:	fcf42e23          	sw	a5,-36(s0)
800026a0:	fdc42703          	lw	a4,-36(s0)
800026a4:	00900793          	li	a5,9
800026a8:	f8e7dce3          	bge	a5,a4,80002640 <schedule+0x1c0>
			}
		}
	}

	if (next_task == -1)
800026ac:	fec42703          	lw	a4,-20(s0)
800026b0:	fff00793          	li	a5,-1
800026b4:	00f71663          	bne	a4,a5,800026c0 <schedule+0x240>
	{
		spin_unlock();
800026b8:	481000ef          	jal	ra,80003338 <spin_unlock>
		// panic("没有可调度的任务");
		return;
800026bc:	0600006f          	j	8000271c <schedule+0x29c>
	}

	_current = next_task;
800026c0:	800067b7          	lui	a5,0x80006
800026c4:	fec42703          	lw	a4,-20(s0)
800026c8:	00e7a023          	sw	a4,0(a5) # 80006000 <_memory_end+0xf8006000>
	struct context *next = &(tasks[_current].ctx);
800026cc:	800067b7          	lui	a5,0x80006
800026d0:	0007a703          	lw	a4,0(a5) # 80006000 <_memory_end+0xf8006000>
800026d4:	09c00793          	li	a5,156
800026d8:	02f70733          	mul	a4,a4,a5
800026dc:	80b067b7          	lui	a5,0x80b06
800026e0:	07078793          	addi	a5,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800026e4:	00f707b3          	add	a5,a4,a5
800026e8:	fcf42a23          	sw	a5,-44(s0)

	tasks[_current].state = TASK_RUNNING;
800026ec:	800067b7          	lui	a5,0x80006
800026f0:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
800026f4:	80b067b7          	lui	a5,0x80b06
800026f8:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800026fc:	09c00793          	li	a5,156
80002700:	02f687b3          	mul	a5,a3,a5
80002704:	00f707b3          	add	a5,a4,a5
80002708:	00200713          	li	a4,2
8000270c:	08e7a823          	sw	a4,144(a5)
	spin_unlock();
80002710:	429000ef          	jal	ra,80003338 <spin_unlock>
	switch_to(next);
80002714:	fd442503          	lw	a0,-44(s0)
80002718:	a69ff0ef          	jal	ra,80002180 <switch_to>
}
8000271c:	02c12083          	lw	ra,44(sp)
80002720:	02812403          	lw	s0,40(sp)
80002724:	03010113          	addi	sp,sp,48
80002728:	00008067          	ret

8000272c <check_timeslice>:

void check_timeslice()
{
8000272c:	ff010113          	addi	sp,sp,-16
80002730:	00112623          	sw	ra,12(sp)
80002734:	00812423          	sw	s0,8(sp)
80002738:	01010413          	addi	s0,sp,16
	tasks[_current].remaining_timeslice--;
8000273c:	800067b7          	lui	a5,0x80006
80002740:	0007a703          	lw	a4,0(a5) # 80006000 <_memory_end+0xf8006000>
80002744:	80b067b7          	lui	a5,0x80b06
80002748:	07078693          	addi	a3,a5,112 # 80b06070 <_memory_end+0xf8b06070>
8000274c:	09c00793          	li	a5,156
80002750:	02f707b3          	mul	a5,a4,a5
80002754:	00f687b3          	add	a5,a3,a5
80002758:	0987a783          	lw	a5,152(a5)
8000275c:	fff78693          	addi	a3,a5,-1
80002760:	80b067b7          	lui	a5,0x80b06
80002764:	07078613          	addi	a2,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002768:	09c00793          	li	a5,156
8000276c:	02f707b3          	mul	a5,a4,a5
80002770:	00f607b3          	add	a5,a2,a5
80002774:	08d7ac23          	sw	a3,152(a5)
	if (tasks[_current].remaining_timeslice == 0)
80002778:	800067b7          	lui	a5,0x80006
8000277c:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
80002780:	80b067b7          	lui	a5,0x80b06
80002784:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002788:	09c00793          	li	a5,156
8000278c:	02f687b3          	mul	a5,a3,a5
80002790:	00f707b3          	add	a5,a4,a5
80002794:	0987a783          	lw	a5,152(a5)
80002798:	04079463          	bnez	a5,800027e0 <check_timeslice+0xb4>
	{
		tasks[_current].remaining_timeslice = tasks[_current].timeslice;
8000279c:	800067b7          	lui	a5,0x80006
800027a0:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
800027a4:	800067b7          	lui	a5,0x80006
800027a8:	0007a603          	lw	a2,0(a5) # 80006000 <_memory_end+0xf8006000>
800027ac:	80b067b7          	lui	a5,0x80b06
800027b0:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800027b4:	09c00793          	li	a5,156
800027b8:	02f687b3          	mul	a5,a3,a5
800027bc:	00f707b3          	add	a5,a4,a5
800027c0:	0947a703          	lw	a4,148(a5)
800027c4:	80b067b7          	lui	a5,0x80b06
800027c8:	07078693          	addi	a3,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800027cc:	09c00793          	li	a5,156
800027d0:	02f607b3          	mul	a5,a2,a5
800027d4:	00f687b3          	add	a5,a3,a5
800027d8:	08e7ac23          	sw	a4,152(a5)
		task_yield();
800027dc:	244000ef          	jal	ra,80002a20 <task_yield>
	}
}
800027e0:	00000013          	nop
800027e4:	00c12083          	lw	ra,12(sp)
800027e8:	00812403          	lw	s0,8(sp)
800027ec:	01010113          	addi	sp,sp,16
800027f0:	00008067          	ret

800027f4 <task_create>:
 * RETURN VALUE
 *  0: success
 *  -1: if error occurred
 */
int task_create(void (*start_routin)(void *param), void *param, uint8_t priority, uint32_t timeslice)
{
800027f4:	fe010113          	addi	sp,sp,-32
800027f8:	00112e23          	sw	ra,28(sp)
800027fc:	00812c23          	sw	s0,24(sp)
80002800:	02010413          	addi	s0,sp,32
80002804:	fea42623          	sw	a0,-20(s0)
80002808:	feb42423          	sw	a1,-24(s0)
8000280c:	00060793          	mv	a5,a2
80002810:	fed42023          	sw	a3,-32(s0)
80002814:	fef403a3          	sb	a5,-25(s0)
	spin_lock();
80002818:	2e5000ef          	jal	ra,800032fc <spin_lock>
	if (_top >= MAX_TASKS)
8000281c:	80b067b7          	lui	a5,0x80b06
80002820:	70c7a703          	lw	a4,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
80002824:	00900793          	li	a5,9
80002828:	00e7d863          	bge	a5,a4,80002838 <task_create+0x44>
	{
		spin_unlock();
8000282c:	30d000ef          	jal	ra,80003338 <spin_unlock>
		return -1;
80002830:	fff00793          	li	a5,-1
80002834:	1d80006f          	j	80002a0c <task_create+0x218>
	}

	tasks[_top].func = start_routin;
80002838:	80b067b7          	lui	a5,0x80b06
8000283c:	70c7a683          	lw	a3,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
80002840:	80b067b7          	lui	a5,0x80b06
80002844:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002848:	09c00793          	li	a5,156
8000284c:	02f687b3          	mul	a5,a3,a5
80002850:	00f707b3          	add	a5,a4,a5
80002854:	fec42703          	lw	a4,-20(s0)
80002858:	08e7a423          	sw	a4,136(a5)
	tasks[_top].param = param;
8000285c:	80b067b7          	lui	a5,0x80b06
80002860:	70c7a683          	lw	a3,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
80002864:	80b067b7          	lui	a5,0x80b06
80002868:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
8000286c:	09c00793          	li	a5,156
80002870:	02f687b3          	mul	a5,a3,a5
80002874:	00f707b3          	add	a5,a4,a5
80002878:	fe842703          	lw	a4,-24(s0)
8000287c:	08e7a223          	sw	a4,132(a5)
	tasks[_top].ctx.sp = (reg_t)&task_stack[_top][STACK_SIZE] & ~0xF;
80002880:	80b067b7          	lui	a5,0x80b06
80002884:	70c7a783          	lw	a5,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
80002888:	00178793          	addi	a5,a5,1
8000288c:	01479713          	slli	a4,a5,0x14
80002890:	800067b7          	lui	a5,0x80006
80002894:	07078793          	addi	a5,a5,112 # 80006070 <_memory_end+0xf8006070>
80002898:	00f707b3          	add	a5,a4,a5
8000289c:	00078713          	mv	a4,a5
800028a0:	80b067b7          	lui	a5,0x80b06
800028a4:	70c7a603          	lw	a2,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
800028a8:	ff077713          	andi	a4,a4,-16
800028ac:	80b067b7          	lui	a5,0x80b06
800028b0:	07078693          	addi	a3,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800028b4:	09c00793          	li	a5,156
800028b8:	02f607b3          	mul	a5,a2,a5
800028bc:	00f687b3          	add	a5,a3,a5
800028c0:	00e7a223          	sw	a4,4(a5)
	tasks[_top].ctx.pc = (reg_t)start_routin;
800028c4:	80b067b7          	lui	a5,0x80b06
800028c8:	70c7a603          	lw	a2,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
800028cc:	fec42703          	lw	a4,-20(s0)
800028d0:	80b067b7          	lui	a5,0x80b06
800028d4:	07078693          	addi	a3,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800028d8:	09c00793          	li	a5,156
800028dc:	02f607b3          	mul	a5,a2,a5
800028e0:	00f687b3          	add	a5,a3,a5
800028e4:	06e7ae23          	sw	a4,124(a5)
	tasks[_top].ctx.a0 = param;
800028e8:	80b067b7          	lui	a5,0x80b06
800028ec:	70c7a603          	lw	a2,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
800028f0:	fe842703          	lw	a4,-24(s0)
800028f4:	80b067b7          	lui	a5,0x80b06
800028f8:	07078693          	addi	a3,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800028fc:	09c00793          	li	a5,156
80002900:	02f607b3          	mul	a5,a2,a5
80002904:	00f687b3          	add	a5,a3,a5
80002908:	02e7a223          	sw	a4,36(a5)
	// 初始化 mstatus 为用户模式，以防后续任务切换时出错
	tasks[_top].ctx.mstatus = (0 << 11) | (1 << 7); // MPP = 0 (用户模式), MPIE = 1
8000290c:	80b067b7          	lui	a5,0x80b06
80002910:	70c7a683          	lw	a3,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
80002914:	80b067b7          	lui	a5,0x80b06
80002918:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
8000291c:	09c00793          	li	a5,156
80002920:	02f687b3          	mul	a5,a3,a5
80002924:	00f707b3          	add	a5,a4,a5
80002928:	08000713          	li	a4,128
8000292c:	08e7a023          	sw	a4,128(a5)

	// 其他初始化代码...
	tasks[_top].priority = priority;
80002930:	80b067b7          	lui	a5,0x80b06
80002934:	70c7a683          	lw	a3,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
80002938:	80b067b7          	lui	a5,0x80b06
8000293c:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002940:	09c00793          	li	a5,156
80002944:	02f687b3          	mul	a5,a3,a5
80002948:	00f707b3          	add	a5,a4,a5
8000294c:	fe744703          	lbu	a4,-25(s0)
80002950:	08e78623          	sb	a4,140(a5)
	tasks[_top].state = TASK_READY;
80002954:	80b067b7          	lui	a5,0x80b06
80002958:	70c7a683          	lw	a3,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
8000295c:	80b067b7          	lui	a5,0x80b06
80002960:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002964:	09c00793          	li	a5,156
80002968:	02f687b3          	mul	a5,a3,a5
8000296c:	00f707b3          	add	a5,a4,a5
80002970:	00100713          	li	a4,1
80002974:	08e7a823          	sw	a4,144(a5)
	tasks[_top].timeslice = timeslice;
80002978:	80b067b7          	lui	a5,0x80b06
8000297c:	70c7a683          	lw	a3,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
80002980:	80b067b7          	lui	a5,0x80b06
80002984:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002988:	09c00793          	li	a5,156
8000298c:	02f687b3          	mul	a5,a3,a5
80002990:	00f707b3          	add	a5,a4,a5
80002994:	fe042703          	lw	a4,-32(s0)
80002998:	08e7aa23          	sw	a4,148(a5)
	tasks[_top].remaining_timeslice = timeslice;
8000299c:	80b067b7          	lui	a5,0x80b06
800029a0:	70c7a683          	lw	a3,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
800029a4:	80b067b7          	lui	a5,0x80b06
800029a8:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800029ac:	09c00793          	li	a5,156
800029b0:	02f687b3          	mul	a5,a3,a5
800029b4:	00f707b3          	add	a5,a4,a5
800029b8:	fe042703          	lw	a4,-32(s0)
800029bc:	08e7ac23          	sw	a4,152(a5)

	printf("创建任务: %p\n", (void *)tasks[_top].ctx.pc);
800029c0:	80b067b7          	lui	a5,0x80b06
800029c4:	70c7a683          	lw	a3,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
800029c8:	80b067b7          	lui	a5,0x80b06
800029cc:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
800029d0:	09c00793          	li	a5,156
800029d4:	02f687b3          	mul	a5,a3,a5
800029d8:	00f707b3          	add	a5,a4,a5
800029dc:	07c7a783          	lw	a5,124(a5)
800029e0:	00078593          	mv	a1,a5
800029e4:	800057b7          	lui	a5,0x80005
800029e8:	69878513          	addi	a0,a5,1688 # 80005698 <_memory_end+0xf8005698>
800029ec:	49c020ef          	jal	ra,80004e88 <printf>

	_top++;
800029f0:	80b067b7          	lui	a5,0x80b06
800029f4:	70c7a783          	lw	a5,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>
800029f8:	00178713          	addi	a4,a5,1
800029fc:	80b067b7          	lui	a5,0x80b06
80002a00:	70e7a623          	sw	a4,1804(a5) # 80b0670c <_memory_end+0xf8b0670c>

	spin_unlock();
80002a04:	135000ef          	jal	ra,80003338 <spin_unlock>
	return 0;
80002a08:	00000793          	li	a5,0
}
80002a0c:	00078513          	mv	a0,a5
80002a10:	01c12083          	lw	ra,28(sp)
80002a14:	01812403          	lw	s0,24(sp)
80002a18:	02010113          	addi	sp,sp,32
80002a1c:	00008067          	ret

80002a20 <task_yield>:
 * DESCRIPTION
 *  task_yield() causes the calling task to relinquish the CPU and a new
 *  task gets to run.
 */
void task_yield(void)
{
80002a20:	fe010113          	addi	sp,sp,-32
80002a24:	00112e23          	sw	ra,28(sp)
80002a28:	00812c23          	sw	s0,24(sp)
80002a2c:	02010413          	addi	s0,sp,32
	spin_lock();
80002a30:	0cd000ef          	jal	ra,800032fc <spin_lock>
	if (_current != -1 && tasks[_current].state == TASK_RUNNING)
80002a34:	800067b7          	lui	a5,0x80006
80002a38:	0007a703          	lw	a4,0(a5) # 80006000 <_memory_end+0xf8006000>
80002a3c:	fff00793          	li	a5,-1
80002a40:	04f70863          	beq	a4,a5,80002a90 <task_yield+0x70>
80002a44:	800067b7          	lui	a5,0x80006
80002a48:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
80002a4c:	80b067b7          	lui	a5,0x80b06
80002a50:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002a54:	09c00793          	li	a5,156
80002a58:	02f687b3          	mul	a5,a3,a5
80002a5c:	00f707b3          	add	a5,a4,a5
80002a60:	0907a703          	lw	a4,144(a5)
80002a64:	00200793          	li	a5,2
80002a68:	02f71463          	bne	a4,a5,80002a90 <task_yield+0x70>
	{
		tasks[_current].state = TASK_READY;
80002a6c:	800067b7          	lui	a5,0x80006
80002a70:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
80002a74:	80b067b7          	lui	a5,0x80b06
80002a78:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002a7c:	09c00793          	li	a5,156
80002a80:	02f687b3          	mul	a5,a3,a5
80002a84:	00f707b3          	add	a5,a4,a5
80002a88:	00100713          	li	a4,1
80002a8c:	08e7a823          	sw	a4,144(a5)
	}
	spin_unlock();
80002a90:	0a9000ef          	jal	ra,80003338 <spin_unlock>

	// 检查当前特权级别并使用对应的调度方式
	if (is_user_mode())
80002a94:	9a9ff0ef          	jal	ra,8000243c <is_user_mode>
80002a98:	00050793          	mv	a5,a0
80002a9c:	02078863          	beqz	a5,80002acc <task_yield+0xac>
	{
		// 在系统调用上下文中，使用软中断方式触发调度
		SCHEDULE;
80002aa0:	ff8ff0ef          	jal	ra,80002298 <r_mhartid>
80002aa4:	00050793          	mv	a5,a0
80002aa8:	fef42623          	sw	a5,-20(s0)
80002aac:	fec42703          	lw	a4,-20(s0)
80002ab0:	008007b7          	lui	a5,0x800
80002ab4:	00f707b3          	add	a5,a4,a5
80002ab8:	00279793          	slli	a5,a5,0x2
80002abc:	00078713          	mv	a4,a5
80002ac0:	00100793          	li	a5,1
80002ac4:	00f72023          	sw	a5,0(a4)
	else
	{
		// 在内核态直接调用调度函数
		schedule();
	}
}
80002ac8:	0080006f          	j	80002ad0 <task_yield+0xb0>
		schedule();
80002acc:	9b5ff0ef          	jal	ra,80002480 <schedule>
}
80002ad0:	00000013          	nop
80002ad4:	01c12083          	lw	ra,28(sp)
80002ad8:	01812403          	lw	s0,24(sp)
80002adc:	02010113          	addi	sp,sp,32
80002ae0:	00008067          	ret

80002ae4 <task_exit>:
/*
 * DESCRIPTION
 *  task_exit() causes the calling task to exit and be removed from the scheduler.
 */
void task_exit()
{
80002ae4:	fe010113          	addi	sp,sp,-32
80002ae8:	00112e23          	sw	ra,28(sp)
80002aec:	00812c23          	sw	s0,24(sp)
80002af0:	02010413          	addi	s0,sp,32
	spin_lock();
80002af4:	009000ef          	jal	ra,800032fc <spin_lock>
	if (_current != -1)
80002af8:	800067b7          	lui	a5,0x80006
80002afc:	0007a703          	lw	a4,0(a5) # 80006000 <_memory_end+0xf8006000>
80002b00:	fff00793          	li	a5,-1
80002b04:	02f70a63          	beq	a4,a5,80002b38 <task_exit+0x54>
	{
		tasks[_current].state = TASK_EXITED;
80002b08:	800067b7          	lui	a5,0x80006
80002b0c:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
80002b10:	80b067b7          	lui	a5,0x80b06
80002b14:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002b18:	09c00793          	li	a5,156
80002b1c:	02f687b3          	mul	a5,a3,a5
80002b20:	00f707b3          	add	a5,a4,a5
80002b24:	00400713          	li	a4,4
80002b28:	08e7a823          	sw	a4,144(a5)
		uart_puts("任务已退出，并被调度器回收。\n");
80002b2c:	800057b7          	lui	a5,0x80005
80002b30:	6ac78513          	addi	a0,a5,1708 # 800056ac <_memory_end+0xf80056ac>
80002b34:	5d4010ef          	jal	ra,80004108 <uart_puts>
	}
	spin_unlock();
80002b38:	001000ef          	jal	ra,80003338 <spin_unlock>
	SCHEDULE
80002b3c:	f5cff0ef          	jal	ra,80002298 <r_mhartid>
80002b40:	00050793          	mv	a5,a0
80002b44:	fef42623          	sw	a5,-20(s0)
80002b48:	fec42703          	lw	a4,-20(s0)
80002b4c:	008007b7          	lui	a5,0x800
80002b50:	00f707b3          	add	a5,a4,a5
80002b54:	00279793          	slli	a5,a5,0x2
80002b58:	00078713          	mv	a4,a5
80002b5c:	00100793          	li	a5,1
80002b60:	00f72023          	sw	a5,0(a4)
	// 如果所有任务都退出，内核可以进入空闲状态或重新启动
	panic("所有任务已退出，系统终止。");
80002b64:	800057b7          	lui	a5,0x80005
80002b68:	6d878513          	addi	a0,a5,1752 # 800056d8 <_memory_end+0xf80056d8>
80002b6c:	390020ef          	jal	ra,80004efc <panic>
}
80002b70:	00000013          	nop
80002b74:	01c12083          	lw	ra,28(sp)
80002b78:	01812403          	lw	s0,24(sp)
80002b7c:	02010113          	addi	sp,sp,32
80002b80:	00008067          	ret

80002b84 <wake_up_task>:

// 定时器回调函数，用于唤醒被延迟的任务
void wake_up_task(void *arg)
{
80002b84:	fd010113          	addi	sp,sp,-48
80002b88:	02812623          	sw	s0,44(sp)
80002b8c:	03010413          	addi	s0,sp,48
80002b90:	fca42e23          	sw	a0,-36(s0)
	int task_id = (int)arg;
80002b94:	fdc42783          	lw	a5,-36(s0)
80002b98:	fef42623          	sw	a5,-20(s0)

	// spin_lock();
	if (task_id >= 0 && task_id < MAX_TASKS && tasks[task_id].state == TASK_SLEEPING)
80002b9c:	fec42783          	lw	a5,-20(s0)
80002ba0:	0407ca63          	bltz	a5,80002bf4 <wake_up_task+0x70>
80002ba4:	fec42703          	lw	a4,-20(s0)
80002ba8:	00900793          	li	a5,9
80002bac:	04e7c463          	blt	a5,a4,80002bf4 <wake_up_task+0x70>
80002bb0:	80b067b7          	lui	a5,0x80b06
80002bb4:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002bb8:	fec42683          	lw	a3,-20(s0)
80002bbc:	09c00793          	li	a5,156
80002bc0:	02f687b3          	mul	a5,a3,a5
80002bc4:	00f707b3          	add	a5,a4,a5
80002bc8:	0907a703          	lw	a4,144(a5)
80002bcc:	00300793          	li	a5,3
80002bd0:	02f71263          	bne	a4,a5,80002bf4 <wake_up_task+0x70>
	{
		tasks[task_id].state = TASK_READY;
80002bd4:	80b067b7          	lui	a5,0x80b06
80002bd8:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002bdc:	fec42683          	lw	a3,-20(s0)
80002be0:	09c00793          	li	a5,156
80002be4:	02f687b3          	mul	a5,a3,a5
80002be8:	00f707b3          	add	a5,a4,a5
80002bec:	00100713          	li	a4,1
80002bf0:	08e7a823          	sw	a4,144(a5)
	}
	// spin_unlock();
}
80002bf4:	00000013          	nop
80002bf8:	02c12403          	lw	s0,44(sp)
80002bfc:	03010113          	addi	sp,sp,48
80002c00:	00008067          	ret

80002c04 <task_delay>:
 * DESCRIPTION
 *  task_delay() causes the calling task to sleep for a specified number of ticks.
 *  - ticks: 延迟的时钟周期数
 */
void task_delay(uint32_t ticks)
{
80002c04:	fd010113          	addi	sp,sp,-48
80002c08:	02112623          	sw	ra,44(sp)
80002c0c:	02812423          	sw	s0,40(sp)
80002c10:	03010413          	addi	s0,sp,48
80002c14:	fca42e23          	sw	a0,-36(s0)
	spin_lock();
80002c18:	6e4000ef          	jal	ra,800032fc <spin_lock>
	if (_current == -1)
80002c1c:	800067b7          	lui	a5,0x80006
80002c20:	0007a703          	lw	a4,0(a5) # 80006000 <_memory_end+0xf8006000>
80002c24:	fff00793          	li	a5,-1
80002c28:	00f71663          	bne	a4,a5,80002c34 <task_delay+0x30>
	{
		spin_unlock();
80002c2c:	70c000ef          	jal	ra,80003338 <spin_unlock>
		return;
80002c30:	0800006f          	j	80002cb0 <task_delay+0xac>
	}

	int task_id = _current;
80002c34:	800067b7          	lui	a5,0x80006
80002c38:	0007a783          	lw	a5,0(a5) # 80006000 <_memory_end+0xf8006000>
80002c3c:	fef42623          	sw	a5,-20(s0)
	tasks[task_id].state = TASK_SLEEPING;
80002c40:	80b067b7          	lui	a5,0x80b06
80002c44:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002c48:	fec42683          	lw	a3,-20(s0)
80002c4c:	09c00793          	li	a5,156
80002c50:	02f687b3          	mul	a5,a3,a5
80002c54:	00f707b3          	add	a5,a4,a5
80002c58:	00300713          	li	a4,3
80002c5c:	08e7a823          	sw	a4,144(a5)
	spin_unlock(); // 解锁，因为timer_create可能会阻塞
80002c60:	6d8000ef          	jal	ra,80003338 <spin_unlock>

	// 创建定时器，ticks 后调用 wake_up_task 以唤醒任务
	if (timer_create(wake_up_task, (void *)task_id, ticks) == NULL)
80002c64:	fec42783          	lw	a5,-20(s0)
80002c68:	fdc42603          	lw	a2,-36(s0)
80002c6c:	00078593          	mv	a1,a5
80002c70:	800037b7          	lui	a5,0x80003
80002c74:	b8478513          	addi	a0,a5,-1148 # 80002b84 <_memory_end+0xf8002b84>
80002c78:	13d010ef          	jal	ra,800045b4 <timer_create>
80002c7c:	00050793          	mv	a5,a0
80002c80:	02079663          	bnez	a5,80002cac <task_delay+0xa8>
	{
		// 定时器创建失败，恢复任务状态为就绪
		spin_lock();
80002c84:	678000ef          	jal	ra,800032fc <spin_lock>
		tasks[task_id].state = TASK_READY;
80002c88:	80b067b7          	lui	a5,0x80b06
80002c8c:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002c90:	fec42683          	lw	a3,-20(s0)
80002c94:	09c00793          	li	a5,156
80002c98:	02f687b3          	mul	a5,a3,a5
80002c9c:	00f707b3          	add	a5,a4,a5
80002ca0:	00100713          	li	a4,1
80002ca4:	08e7a823          	sw	a4,144(a5)
		spin_unlock();
80002ca8:	690000ef          	jal	ra,80003338 <spin_unlock>
	}

	// 让出 CPU，触发调度
	task_yield();
80002cac:	d75ff0ef          	jal	ra,80002a20 <task_yield>
}
80002cb0:	02c12083          	lw	ra,44(sp)
80002cb4:	02812403          	lw	s0,40(sp)
80002cb8:	03010113          	addi	sp,sp,48
80002cbc:	00008067          	ret

80002cc0 <get_task_func_name>:

/* 获取任务函数名称 */
static const char *get_task_func_name(void (*func)(void *))
{
80002cc0:	fe010113          	addi	sp,sp,-32
80002cc4:	00812e23          	sw	s0,28(sp)
80002cc8:	02010413          	addi	s0,sp,32
80002ccc:	fea42623          	sw	a0,-20(s0)
	if (func == user_task0)
80002cd0:	fec42703          	lw	a4,-20(s0)
80002cd4:	800057b7          	lui	a5,0x80005
80002cd8:	20478793          	addi	a5,a5,516 # 80005204 <_memory_end+0xf8005204>
80002cdc:	00f71863          	bne	a4,a5,80002cec <get_task_func_name+0x2c>
		return "user_task0";
80002ce0:	800057b7          	lui	a5,0x80005
80002ce4:	70078793          	addi	a5,a5,1792 # 80005700 <_memory_end+0xf8005700>
80002ce8:	07c0006f          	j	80002d64 <get_task_func_name+0xa4>
	if (func == user_task1)
80002cec:	fec42703          	lw	a4,-20(s0)
80002cf0:	800057b7          	lui	a5,0x80005
80002cf4:	23c78793          	addi	a5,a5,572 # 8000523c <_memory_end+0xf800523c>
80002cf8:	00f71863          	bne	a4,a5,80002d08 <get_task_func_name+0x48>
		return "user_task1";
80002cfc:	800057b7          	lui	a5,0x80005
80002d00:	70c78793          	addi	a5,a5,1804 # 8000570c <_memory_end+0xf800570c>
80002d04:	0600006f          	j	80002d64 <get_task_func_name+0xa4>
	if (func == user_task)
80002d08:	fec42703          	lw	a4,-20(s0)
80002d0c:	800057b7          	lui	a5,0x80005
80002d10:	27478793          	addi	a5,a5,628 # 80005274 <_memory_end+0xf8005274>
80002d14:	00f71863          	bne	a4,a5,80002d24 <get_task_func_name+0x64>
		return "user_task";
80002d18:	800057b7          	lui	a5,0x80005
80002d1c:	71878793          	addi	a5,a5,1816 # 80005718 <_memory_end+0xf8005718>
80002d20:	0440006f          	j	80002d64 <get_task_func_name+0xa4>
	if (func == timer_handler)
80002d24:	fec42703          	lw	a4,-20(s0)
80002d28:	800047b7          	lui	a5,0x80004
80002d2c:	78478793          	addi	a5,a5,1924 # 80004784 <_memory_end+0xf8004784>
80002d30:	00f71863          	bne	a4,a5,80002d40 <get_task_func_name+0x80>
		return "timer_handler";
80002d34:	800057b7          	lui	a5,0x80005
80002d38:	72478793          	addi	a5,a5,1828 # 80005724 <_memory_end+0xf8005724>
80002d3c:	0280006f          	j	80002d64 <get_task_func_name+0xa4>
	if (func == task_yield)
80002d40:	fec42703          	lw	a4,-20(s0)
80002d44:	800037b7          	lui	a5,0x80003
80002d48:	a2078793          	addi	a5,a5,-1504 # 80002a20 <_memory_end+0xf8002a20>
80002d4c:	00f71863          	bne	a4,a5,80002d5c <get_task_func_name+0x9c>
		return "task_yield";
80002d50:	800057b7          	lui	a5,0x80005
80002d54:	73478793          	addi	a5,a5,1844 # 80005734 <_memory_end+0xf8005734>
80002d58:	00c0006f          	j	80002d64 <get_task_func_name+0xa4>
	return "unknown";
80002d5c:	800057b7          	lui	a5,0x80005
80002d60:	74078793          	addi	a5,a5,1856 # 80005740 <_memory_end+0xf8005740>
}
80002d64:	00078513          	mv	a0,a5
80002d68:	01c12403          	lw	s0,28(sp)
80002d6c:	02010113          	addi	sp,sp,32
80002d70:	00008067          	ret

80002d74 <print_tasks>:

/* 打印任务槽信息的调试函数 */
void print_tasks(void)
{
80002d74:	fe010113          	addi	sp,sp,-32
80002d78:	00112e23          	sw	ra,28(sp)
80002d7c:	00812c23          	sw	s0,24(sp)
80002d80:	02010413          	addi	s0,sp,32
	printf("\n=== Tasks Debug Info ===\n");
80002d84:	800057b7          	lui	a5,0x80005
80002d88:	74878513          	addi	a0,a5,1864 # 80005748 <_memory_end+0xf8005748>
80002d8c:	0fc020ef          	jal	ra,80004e88 <printf>

	int active_tasks = 0;
80002d90:	fe042623          	sw	zero,-20(s0)
	for (int i = 0; i < MAX_TASKS; i++)
80002d94:	fe042423          	sw	zero,-24(s0)
80002d98:	1e00006f          	j	80002f78 <print_tasks+0x204>
	{
		if (tasks[i].state != TASK_INVALID)
80002d9c:	80b067b7          	lui	a5,0x80b06
80002da0:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002da4:	fe842683          	lw	a3,-24(s0)
80002da8:	09c00793          	li	a5,156
80002dac:	02f687b3          	mul	a5,a3,a5
80002db0:	00f707b3          	add	a5,a4,a5
80002db4:	0907a783          	lw	a5,144(a5)
80002db8:	1a078a63          	beqz	a5,80002f6c <print_tasks+0x1f8>
		{
			printf("Task[%d]:\n", i);
80002dbc:	fe842583          	lw	a1,-24(s0)
80002dc0:	800057b7          	lui	a5,0x80005
80002dc4:	76478513          	addi	a0,a5,1892 # 80005764 <_memory_end+0xf8005764>
80002dc8:	0c0020ef          	jal	ra,80004e88 <printf>
			printf("  Function: %s\n", get_task_func_name(tasks[i].func));
80002dcc:	80b067b7          	lui	a5,0x80b06
80002dd0:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002dd4:	fe842683          	lw	a3,-24(s0)
80002dd8:	09c00793          	li	a5,156
80002ddc:	02f687b3          	mul	a5,a3,a5
80002de0:	00f707b3          	add	a5,a4,a5
80002de4:	0887a783          	lw	a5,136(a5)
80002de8:	00078513          	mv	a0,a5
80002dec:	ed5ff0ef          	jal	ra,80002cc0 <get_task_func_name>
80002df0:	00050793          	mv	a5,a0
80002df4:	00078593          	mv	a1,a5
80002df8:	800057b7          	lui	a5,0x80005
80002dfc:	77078513          	addi	a0,a5,1904 # 80005770 <_memory_end+0xf8005770>
80002e00:	088020ef          	jal	ra,80004e88 <printf>
			if (tasks[i].func == user_task)
80002e04:	80b067b7          	lui	a5,0x80b06
80002e08:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002e0c:	fe842683          	lw	a3,-24(s0)
80002e10:	09c00793          	li	a5,156
80002e14:	02f687b3          	mul	a5,a3,a5
80002e18:	00f707b3          	add	a5,a4,a5
80002e1c:	0887a703          	lw	a4,136(a5)
80002e20:	800057b7          	lui	a5,0x80005
80002e24:	27478793          	addi	a5,a5,628 # 80005274 <_memory_end+0xf8005274>
80002e28:	02f71a63          	bne	a4,a5,80002e5c <print_tasks+0xe8>
			{
				int task_id = (int)(tasks[i].param);
80002e2c:	80b067b7          	lui	a5,0x80b06
80002e30:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002e34:	fe842683          	lw	a3,-24(s0)
80002e38:	09c00793          	li	a5,156
80002e3c:	02f687b3          	mul	a5,a3,a5
80002e40:	00f707b3          	add	a5,a4,a5
80002e44:	0847a783          	lw	a5,132(a5)
80002e48:	fef42023          	sw	a5,-32(s0)
				printf("  Task ID: %d\n", task_id);
80002e4c:	fe042583          	lw	a1,-32(s0)
80002e50:	800057b7          	lui	a5,0x80005
80002e54:	78078513          	addi	a0,a5,1920 # 80005780 <_memory_end+0xf8005780>
80002e58:	030020ef          	jal	ra,80004e88 <printf>
			}
			printf("  Priority: %d\n", tasks[i].priority);
80002e5c:	80b067b7          	lui	a5,0x80b06
80002e60:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002e64:	fe842683          	lw	a3,-24(s0)
80002e68:	09c00793          	li	a5,156
80002e6c:	02f687b3          	mul	a5,a3,a5
80002e70:	00f707b3          	add	a5,a4,a5
80002e74:	08c7c783          	lbu	a5,140(a5)
80002e78:	00078593          	mv	a1,a5
80002e7c:	800057b7          	lui	a5,0x80005
80002e80:	79078513          	addi	a0,a5,1936 # 80005790 <_memory_end+0xf8005790>
80002e84:	004020ef          	jal	ra,80004e88 <printf>

			const char *state_str;
			switch (tasks[i].state)
80002e88:	80b067b7          	lui	a5,0x80b06
80002e8c:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80002e90:	fe842683          	lw	a3,-24(s0)
80002e94:	09c00793          	li	a5,156
80002e98:	02f687b3          	mul	a5,a3,a5
80002e9c:	00f707b3          	add	a5,a4,a5
80002ea0:	0907a783          	lw	a5,144(a5)
80002ea4:	00400713          	li	a4,4
80002ea8:	06e78063          	beq	a5,a4,80002f08 <print_tasks+0x194>
80002eac:	00400713          	li	a4,4
80002eb0:	06f76463          	bltu	a4,a5,80002f18 <print_tasks+0x1a4>
80002eb4:	00300713          	li	a4,3
80002eb8:	04e78063          	beq	a5,a4,80002ef8 <print_tasks+0x184>
80002ebc:	00300713          	li	a4,3
80002ec0:	04f76c63          	bltu	a4,a5,80002f18 <print_tasks+0x1a4>
80002ec4:	00100713          	li	a4,1
80002ec8:	00e78863          	beq	a5,a4,80002ed8 <print_tasks+0x164>
80002ecc:	00200713          	li	a4,2
80002ed0:	00e78c63          	beq	a5,a4,80002ee8 <print_tasks+0x174>
80002ed4:	0440006f          	j	80002f18 <print_tasks+0x1a4>
			{
			case TASK_READY:
				state_str = "READY";
80002ed8:	800057b7          	lui	a5,0x80005
80002edc:	7a078793          	addi	a5,a5,1952 # 800057a0 <_memory_end+0xf80057a0>
80002ee0:	fef42223          	sw	a5,-28(s0)
				break;
80002ee4:	0440006f          	j	80002f28 <print_tasks+0x1b4>
			case TASK_RUNNING:
				state_str = "RUNNING";
80002ee8:	800057b7          	lui	a5,0x80005
80002eec:	7a878793          	addi	a5,a5,1960 # 800057a8 <_memory_end+0xf80057a8>
80002ef0:	fef42223          	sw	a5,-28(s0)
				break;
80002ef4:	0340006f          	j	80002f28 <print_tasks+0x1b4>
			case TASK_SLEEPING:
				state_str = "SLEEPING";
80002ef8:	800057b7          	lui	a5,0x80005
80002efc:	7b078793          	addi	a5,a5,1968 # 800057b0 <_memory_end+0xf80057b0>
80002f00:	fef42223          	sw	a5,-28(s0)
				break;
80002f04:	0240006f          	j	80002f28 <print_tasks+0x1b4>
			case TASK_EXITED:
				state_str = "EXITED";
80002f08:	800057b7          	lui	a5,0x80005
80002f0c:	7bc78793          	addi	a5,a5,1980 # 800057bc <_memory_end+0xf80057bc>
80002f10:	fef42223          	sw	a5,-28(s0)
				break;
80002f14:	0140006f          	j	80002f28 <print_tasks+0x1b4>
			default:
				state_str = "UNKNOWN";
80002f18:	800057b7          	lui	a5,0x80005
80002f1c:	7c478793          	addi	a5,a5,1988 # 800057c4 <_memory_end+0xf80057c4>
80002f20:	fef42223          	sw	a5,-28(s0)
				break;
80002f24:	00000013          	nop
			}
			printf("  State: %s\n", state_str);
80002f28:	fe442583          	lw	a1,-28(s0)
80002f2c:	800057b7          	lui	a5,0x80005
80002f30:	7cc78513          	addi	a0,a5,1996 # 800057cc <_memory_end+0xf80057cc>
80002f34:	755010ef          	jal	ra,80004e88 <printf>
			if (i == _current)
80002f38:	800067b7          	lui	a5,0x80006
80002f3c:	0007a783          	lw	a5,0(a5) # 80006000 <_memory_end+0xf8006000>
80002f40:	fe842703          	lw	a4,-24(s0)
80002f44:	00f71863          	bne	a4,a5,80002f54 <print_tasks+0x1e0>
			{
				printf("  [CURRENT]\n");
80002f48:	800057b7          	lui	a5,0x80005
80002f4c:	7dc78513          	addi	a0,a5,2012 # 800057dc <_memory_end+0xf80057dc>
80002f50:	739010ef          	jal	ra,80004e88 <printf>
			}
			printf("------------------\n");
80002f54:	800057b7          	lui	a5,0x80005
80002f58:	7ec78513          	addi	a0,a5,2028 # 800057ec <_memory_end+0xf80057ec>
80002f5c:	72d010ef          	jal	ra,80004e88 <printf>
			active_tasks++;
80002f60:	fec42783          	lw	a5,-20(s0)
80002f64:	00178793          	addi	a5,a5,1
80002f68:	fef42623          	sw	a5,-20(s0)
	for (int i = 0; i < MAX_TASKS; i++)
80002f6c:	fe842783          	lw	a5,-24(s0)
80002f70:	00178793          	addi	a5,a5,1
80002f74:	fef42423          	sw	a5,-24(s0)
80002f78:	fe842703          	lw	a4,-24(s0)
80002f7c:	00900793          	li	a5,9
80002f80:	e0e7dee3          	bge	a5,a4,80002d9c <print_tasks+0x28>
		}
	}
	printf("Active tasks: %d, Current: %d\n", active_tasks, _current);
80002f84:	800067b7          	lui	a5,0x80006
80002f88:	0007a783          	lw	a5,0(a5) # 80006000 <_memory_end+0xf8006000>
80002f8c:	00078613          	mv	a2,a5
80002f90:	fec42583          	lw	a1,-20(s0)
80002f94:	800067b7          	lui	a5,0x80006
80002f98:	80078513          	addi	a0,a5,-2048 # 80005800 <_memory_end+0xf8005800>
80002f9c:	6ed010ef          	jal	ra,80004e88 <printf>
	printf("=== End of Tasks Info ===\n\n");
80002fa0:	800067b7          	lui	a5,0x80006
80002fa4:	82078513          	addi	a0,a5,-2016 # 80005820 <_memory_end+0xf8005820>
80002fa8:	6e1010ef          	jal	ra,80004e88 <printf>
80002fac:	00000013          	nop
80002fb0:	01c12083          	lw	ra,28(sp)
80002fb4:	01812403          	lw	s0,24(sp)
80002fb8:	02010113          	addi	sp,sp,32
80002fbc:	00008067          	ret

80002fc0 <r_mhartid>:
{
80002fc0:	fe010113          	addi	sp,sp,-32
80002fc4:	00812e23          	sw	s0,28(sp)
80002fc8:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mhartid" : "=r" (x) );
80002fcc:	f14027f3          	csrr	a5,mhartid
80002fd0:	fef42623          	sw	a5,-20(s0)
	return x;
80002fd4:	fec42783          	lw	a5,-20(s0)
}
80002fd8:	00078513          	mv	a0,a5
80002fdc:	01c12403          	lw	s0,28(sp)
80002fe0:	02010113          	addi	sp,sp,32
80002fe4:	00008067          	ret

80002fe8 <r_mstatus>:
{
80002fe8:	fe010113          	addi	sp,sp,-32
80002fec:	00812e23          	sw	s0,28(sp)
80002ff0:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mstatus" : "=r" (x) );
80002ff4:	300027f3          	csrr	a5,mstatus
80002ff8:	fef42623          	sw	a5,-20(s0)
	return x;
80002ffc:	fec42783          	lw	a5,-20(s0)
}
80003000:	00078513          	mv	a0,a5
80003004:	01c12403          	lw	s0,28(sp)
80003008:	02010113          	addi	sp,sp,32
8000300c:	00008067          	ret

80003010 <w_mstatus>:
{
80003010:	fe010113          	addi	sp,sp,-32
80003014:	00812e23          	sw	s0,28(sp)
80003018:	02010413          	addi	s0,sp,32
8000301c:	fea42623          	sw	a0,-20(s0)
	asm volatile("csrw mstatus, %0" : : "r" (x));
80003020:	fec42783          	lw	a5,-20(s0)
80003024:	30079073          	csrw	mstatus,a5
}
80003028:	00000013          	nop
8000302c:	01c12403          	lw	s0,28(sp)
80003030:	02010113          	addi	sp,sp,32
80003034:	00008067          	ret

80003038 <w_mtvec>:
{
80003038:	fe010113          	addi	sp,sp,-32
8000303c:	00812e23          	sw	s0,28(sp)
80003040:	02010413          	addi	s0,sp,32
80003044:	fea42623          	sw	a0,-20(s0)
	asm volatile("csrw mtvec, %0" : : "r" (x));
80003048:	fec42783          	lw	a5,-20(s0)
8000304c:	30579073          	csrw	mtvec,a5
}
80003050:	00000013          	nop
80003054:	01c12403          	lw	s0,28(sp)
80003058:	02010113          	addi	sp,sp,32
8000305c:	00008067          	ret

80003060 <trap_init>:
extern void timer_handler(void);
extern void schedule(void);
extern void handle_syscall(reg_t epc, reg_t cause);

void trap_init()
{
80003060:	ff010113          	addi	sp,sp,-16
80003064:	00112623          	sw	ra,12(sp)
80003068:	00812423          	sw	s0,8(sp)
8000306c:	01010413          	addi	s0,sp,16
	/*
	 * set the trap-vector base-address for machine-mode
	 */
	w_mtvec((reg_t)trap_vector);
80003070:	800027b7          	lui	a5,0x80002
80003074:	06878793          	addi	a5,a5,104 # 80002068 <_memory_end+0xf8002068>
80003078:	00078513          	mv	a0,a5
8000307c:	fbdff0ef          	jal	ra,80003038 <w_mtvec>
}
80003080:	00000013          	nop
80003084:	00c12083          	lw	ra,12(sp)
80003088:	00812403          	lw	s0,8(sp)
8000308c:	01010113          	addi	sp,sp,16
80003090:	00008067          	ret

80003094 <external_interrupt_handler>:

void external_interrupt_handler()
{
80003094:	fe010113          	addi	sp,sp,-32
80003098:	00112e23          	sw	ra,28(sp)
8000309c:	00812c23          	sw	s0,24(sp)
800030a0:	02010413          	addi	s0,sp,32
	int irq = plic_claim();
800030a4:	2c8010ef          	jal	ra,8000436c <plic_claim>
800030a8:	fea42623          	sw	a0,-20(s0)

	if (irq == UART0_IRQ)
800030ac:	fec42703          	lw	a4,-20(s0)
800030b0:	00a00793          	li	a5,10
800030b4:	00f71663          	bne	a4,a5,800030c0 <external_interrupt_handler+0x2c>
	{
		uart_isr();
800030b8:	0ec010ef          	jal	ra,800041a4 <uart_isr>
800030bc:	01c0006f          	j	800030d8 <external_interrupt_handler+0x44>
	}
	else if (irq)
800030c0:	fec42783          	lw	a5,-20(s0)
800030c4:	00078a63          	beqz	a5,800030d8 <external_interrupt_handler+0x44>
	{
		printf("unexpected interrupt irq = %d\n", irq);
800030c8:	fec42583          	lw	a1,-20(s0)
800030cc:	800067b7          	lui	a5,0x80006
800030d0:	83c78513          	addi	a0,a5,-1988 # 8000583c <_memory_end+0xf800583c>
800030d4:	5b5010ef          	jal	ra,80004e88 <printf>
	}

	if (irq)
800030d8:	fec42783          	lw	a5,-20(s0)
800030dc:	00078663          	beqz	a5,800030e8 <external_interrupt_handler+0x54>
	{
		plic_complete(irq);
800030e0:	fec42503          	lw	a0,-20(s0)
800030e4:	2d8010ef          	jal	ra,800043bc <plic_complete>
	}
}
800030e8:	00000013          	nop
800030ec:	01c12083          	lw	ra,28(sp)
800030f0:	01812403          	lw	s0,24(sp)
800030f4:	02010113          	addi	sp,sp,32
800030f8:	00008067          	ret

800030fc <trap_handler>:

reg_t trap_handler(reg_t epc, reg_t cause)
{
800030fc:	fc010113          	addi	sp,sp,-64
80003100:	02112e23          	sw	ra,60(sp)
80003104:	02812c23          	sw	s0,56(sp)
80003108:	04010413          	addi	s0,sp,64
8000310c:	fca42623          	sw	a0,-52(s0)
80003110:	fcb42423          	sw	a1,-56(s0)
	// printf("异常发生！epc = %x, cause = %x\n", epc, cause);
	reg_t return_pc = epc;
80003114:	fcc42783          	lw	a5,-52(s0)
80003118:	fef42623          	sw	a5,-20(s0)
	reg_t cause_code = cause & 0xfff;
8000311c:	fc842703          	lw	a4,-56(s0)
80003120:	000017b7          	lui	a5,0x1
80003124:	fff78793          	addi	a5,a5,-1 # fff <STACK_SIZE+0xbff>
80003128:	00f777b3          	and	a5,a4,a5
8000312c:	fef42423          	sw	a5,-24(s0)

	if (cause & 0x80000000)
80003130:	fc842783          	lw	a5,-56(s0)
80003134:	0807d063          	bgez	a5,800031b4 <trap_handler+0xb8>
	{
		/* 异步陷阱 - 中断 */
		switch (cause_code)
80003138:	fe842703          	lw	a4,-24(s0)
8000313c:	00b00793          	li	a5,11
80003140:	04f70e63          	beq	a4,a5,8000319c <trap_handler+0xa0>
80003144:	fe842703          	lw	a4,-24(s0)
80003148:	00b00793          	li	a5,11
8000314c:	04e7ec63          	bltu	a5,a4,800031a4 <trap_handler+0xa8>
80003150:	fe842703          	lw	a4,-24(s0)
80003154:	00300793          	li	a5,3
80003158:	00f70a63          	beq	a4,a5,8000316c <trap_handler+0x70>
8000315c:	fe842703          	lw	a4,-24(s0)
80003160:	00700793          	li	a5,7
80003164:	02f70863          	beq	a4,a5,80003194 <trap_handler+0x98>
80003168:	03c0006f          	j	800031a4 <trap_handler+0xa8>
			// uart_puts("软件中断！\n");
			/*
			 * 清除软件中断
			 */
			{
				int id = r_mhartid();
8000316c:	e55ff0ef          	jal	ra,80002fc0 <r_mhartid>
80003170:	00050793          	mv	a5,a0
80003174:	fcf42e23          	sw	a5,-36(s0)
				*(uint32_t *)CLINT_MSIP(id) = 0;
80003178:	fdc42703          	lw	a4,-36(s0)
8000317c:	008007b7          	lui	a5,0x800
80003180:	00f707b3          	add	a5,a4,a5
80003184:	00279793          	slli	a5,a5,0x2
80003188:	0007a023          	sw	zero,0(a5) # 800000 <STACK_SIZE+0x7ffc00>

				// 切换到内核调度任务
				schedule();
8000318c:	af4ff0ef          	jal	ra,80002480 <schedule>
				break;
80003190:	1040006f          	j	80003294 <trap_handler+0x198>
			}
		case 7:
			// uart_puts("定时器中断！\n");
			timer_handler();
80003194:	5f0010ef          	jal	ra,80004784 <timer_handler>
			break;
80003198:	0fc0006f          	j	80003294 <trap_handler+0x198>
		case 11:
			// uart_puts("外部中断！\n");
			external_interrupt_handler();
8000319c:	ef9ff0ef          	jal	ra,80003094 <external_interrupt_handler>
			break;
800031a0:	0f40006f          	j	80003294 <trap_handler+0x198>
		default:
			uart_puts("未知的异步异常！\n");
800031a4:	800067b7          	lui	a5,0x80006
800031a8:	85c78513          	addi	a0,a5,-1956 # 8000585c <_memory_end+0xf800585c>
800031ac:	75d000ef          	jal	ra,80004108 <uart_puts>
			break;
800031b0:	0e40006f          	j	80003294 <trap_handler+0x198>
		}
	}
	else
	{
		/* 同步陷阱 - 异常 */
		switch (cause_code)
800031b4:	fe842703          	lw	a4,-24(s0)
800031b8:	00800793          	li	a5,8
800031bc:	00f70863          	beq	a4,a5,800031cc <trap_handler+0xd0>
800031c0:	fe842703          	lw	a4,-24(s0)
800031c4:	00b00793          	li	a5,11
800031c8:	08f71c63          	bne	a4,a5,80003260 <trap_handler+0x164>
		{
		case 8:	 // 环境调用（来自用户模式）
		case 11: // 环境调用（来自机器模式）
			// 系统调用处理
			return_pc += 4;				// 跳过 ecall 指令
800031cc:	fec42783          	lw	a5,-20(s0)
800031d0:	00478793          	addi	a5,a5,4
800031d4:	fef42623          	sw	a5,-20(s0)
			handle_syscall(epc, cause); // 只传递epc和cause
800031d8:	fc842583          	lw	a1,-56(s0)
800031dc:	fcc42503          	lw	a0,-52(s0)
800031e0:	3d9000ef          	jal	ra,80003db8 <handle_syscall>

			// 确保正确设置返回的特权级别
			if (cause_code == 8)
800031e4:	fe842703          	lw	a4,-24(s0)
800031e8:	00800793          	li	a5,8
800031ec:	02f71663          	bne	a4,a5,80003218 <trap_handler+0x11c>
			{
				// 用户模式调用，确保返回用户模式
				reg_t mstatus = r_mstatus();
800031f0:	df9ff0ef          	jal	ra,80002fe8 <r_mstatus>
800031f4:	fea42023          	sw	a0,-32(s0)
				mstatus &= ~MSTATUS_MPP; // 清除MPP位(设为用户模式)
800031f8:	fe042703          	lw	a4,-32(s0)
800031fc:	ffffe7b7          	lui	a5,0xffffe
80003200:	7ff78793          	addi	a5,a5,2047 # ffffe7ff <_memory_end+0x77ffe7ff>
80003204:	00f777b3          	and	a5,a4,a5
80003208:	fef42023          	sw	a5,-32(s0)
				w_mstatus(mstatus);
8000320c:	fe042503          	lw	a0,-32(s0)
80003210:	e01ff0ef          	jal	ra,80003010 <w_mstatus>
				reg_t mstatus = r_mstatus();
				mstatus &= ~MSTATUS_MPP;
				mstatus |= 3 << 11; // 设置MPP为机器模式(3)
				w_mstatus(mstatus);
			}
			break;
80003214:	07c0006f          	j	80003290 <trap_handler+0x194>
			else if (cause_code == 11)
80003218:	fe842703          	lw	a4,-24(s0)
8000321c:	00b00793          	li	a5,11
80003220:	06f71863          	bne	a4,a5,80003290 <trap_handler+0x194>
				reg_t mstatus = r_mstatus();
80003224:	dc5ff0ef          	jal	ra,80002fe8 <r_mstatus>
80003228:	fea42223          	sw	a0,-28(s0)
				mstatus &= ~MSTATUS_MPP;
8000322c:	fe442703          	lw	a4,-28(s0)
80003230:	ffffe7b7          	lui	a5,0xffffe
80003234:	7ff78793          	addi	a5,a5,2047 # ffffe7ff <_memory_end+0x77ffe7ff>
80003238:	00f777b3          	and	a5,a4,a5
8000323c:	fef42223          	sw	a5,-28(s0)
				mstatus |= 3 << 11; // 设置MPP为机器模式(3)
80003240:	fe442703          	lw	a4,-28(s0)
80003244:	000027b7          	lui	a5,0x2
80003248:	80078793          	addi	a5,a5,-2048 # 1800 <STACK_SIZE+0x1400>
8000324c:	00f767b3          	or	a5,a4,a5
80003250:	fef42223          	sw	a5,-28(s0)
				w_mstatus(mstatus);
80003254:	fe442503          	lw	a0,-28(s0)
80003258:	db9ff0ef          	jal	ra,80003010 <w_mstatus>
			break;
8000325c:	0340006f          	j	80003290 <trap_handler+0x194>
		default:
			printf("同步异常!, code = %d, epc = %x\n", cause_code, epc);
80003260:	fcc42603          	lw	a2,-52(s0)
80003264:	fe842583          	lw	a1,-24(s0)
80003268:	800067b7          	lui	a5,0x80006
8000326c:	87878513          	addi	a0,a5,-1928 # 80005878 <_memory_end+0xf8005878>
80003270:	419010ef          	jal	ra,80004e88 <printf>
			panic("OOPS! 无法处理的异常！");
80003274:	800067b7          	lui	a5,0x80006
80003278:	89c78513          	addi	a0,a5,-1892 # 8000589c <_memory_end+0xf800589c>
8000327c:	481010ef          	jal	ra,80004efc <panic>
			return_pc += 4;
80003280:	fec42783          	lw	a5,-20(s0)
80003284:	00478793          	addi	a5,a5,4
80003288:	fef42623          	sw	a5,-20(s0)
			break;
8000328c:	0080006f          	j	80003294 <trap_handler+0x198>
			break;
80003290:	00000013          	nop
		}
	}

	return return_pc;
80003294:	fec42783          	lw	a5,-20(s0)
}
80003298:	00078513          	mv	a0,a5
8000329c:	03c12083          	lw	ra,60(sp)
800032a0:	03812403          	lw	s0,56(sp)
800032a4:	04010113          	addi	sp,sp,64
800032a8:	00008067          	ret

800032ac <r_mstatus>:
{
800032ac:	fe010113          	addi	sp,sp,-32
800032b0:	00812e23          	sw	s0,28(sp)
800032b4:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mstatus" : "=r" (x) );
800032b8:	300027f3          	csrr	a5,mstatus
800032bc:	fef42623          	sw	a5,-20(s0)
	return x;
800032c0:	fec42783          	lw	a5,-20(s0)
}
800032c4:	00078513          	mv	a0,a5
800032c8:	01c12403          	lw	s0,28(sp)
800032cc:	02010113          	addi	sp,sp,32
800032d0:	00008067          	ret

800032d4 <w_mstatus>:
{
800032d4:	fe010113          	addi	sp,sp,-32
800032d8:	00812e23          	sw	s0,28(sp)
800032dc:	02010413          	addi	s0,sp,32
800032e0:	fea42623          	sw	a0,-20(s0)
	asm volatile("csrw mstatus, %0" : : "r" (x));
800032e4:	fec42783          	lw	a5,-20(s0)
800032e8:	30079073          	csrw	mstatus,a5
}
800032ec:	00000013          	nop
800032f0:	01c12403          	lw	s0,28(sp)
800032f4:	02010113          	addi	sp,sp,32
800032f8:	00008067          	ret

800032fc <spin_lock>:
#include "os.h"

int spin_lock()
{
800032fc:	ff010113          	addi	sp,sp,-16
80003300:	00112623          	sw	ra,12(sp)
80003304:	00812423          	sw	s0,8(sp)
80003308:	01010413          	addi	s0,sp,16
	w_mstatus(r_mstatus() & ~MSTATUS_MIE);
8000330c:	fa1ff0ef          	jal	ra,800032ac <r_mstatus>
80003310:	00050793          	mv	a5,a0
80003314:	ff77f793          	andi	a5,a5,-9
80003318:	00078513          	mv	a0,a5
8000331c:	fb9ff0ef          	jal	ra,800032d4 <w_mstatus>
	return 0;
80003320:	00000793          	li	a5,0
}
80003324:	00078513          	mv	a0,a5
80003328:	00c12083          	lw	ra,12(sp)
8000332c:	00812403          	lw	s0,8(sp)
80003330:	01010113          	addi	sp,sp,16
80003334:	00008067          	ret

80003338 <spin_unlock>:

int spin_unlock()
{
80003338:	ff010113          	addi	sp,sp,-16
8000333c:	00112623          	sw	ra,12(sp)
80003340:	00812423          	sw	s0,8(sp)
80003344:	01010413          	addi	s0,sp,16
	w_mstatus(r_mstatus() | MSTATUS_MIE);
80003348:	f65ff0ef          	jal	ra,800032ac <r_mstatus>
8000334c:	00050793          	mv	a5,a0
80003350:	0087e793          	ori	a5,a5,8
80003354:	00078513          	mv	a0,a5
80003358:	f7dff0ef          	jal	ra,800032d4 <w_mstatus>
	return 0;
8000335c:	00000793          	li	a5,0
}
80003360:	00078513          	mv	a0,a5
80003364:	00c12083          	lw	ra,12(sp)
80003368:	00812403          	lw	s0,8(sp)
8000336c:	01010113          	addi	sp,sp,16
80003370:	00008067          	ret

80003374 <_clear>:
struct Page {
	uint8_t flags;
};

static inline void _clear(struct Page *page)
{
80003374:	fe010113          	addi	sp,sp,-32
80003378:	00812e23          	sw	s0,28(sp)
8000337c:	02010413          	addi	s0,sp,32
80003380:	fea42623          	sw	a0,-20(s0)
	page->flags = 0;
80003384:	fec42783          	lw	a5,-20(s0)
80003388:	00078023          	sb	zero,0(a5)
}
8000338c:	00000013          	nop
80003390:	01c12403          	lw	s0,28(sp)
80003394:	02010113          	addi	sp,sp,32
80003398:	00008067          	ret

8000339c <_is_free>:

static inline int _is_free(struct Page *page)
{
8000339c:	fe010113          	addi	sp,sp,-32
800033a0:	00812e23          	sw	s0,28(sp)
800033a4:	02010413          	addi	s0,sp,32
800033a8:	fea42623          	sw	a0,-20(s0)
	if (page->flags & PAGE_TAKEN) {
800033ac:	fec42783          	lw	a5,-20(s0)
800033b0:	0007c783          	lbu	a5,0(a5)
800033b4:	0017f793          	andi	a5,a5,1
800033b8:	00078663          	beqz	a5,800033c4 <_is_free+0x28>
		return 0;
800033bc:	00000793          	li	a5,0
800033c0:	0080006f          	j	800033c8 <_is_free+0x2c>
	} else {
		return 1;
800033c4:	00100793          	li	a5,1
	}
}
800033c8:	00078513          	mv	a0,a5
800033cc:	01c12403          	lw	s0,28(sp)
800033d0:	02010113          	addi	sp,sp,32
800033d4:	00008067          	ret

800033d8 <_set_flag>:

static inline void _set_flag(struct Page *page, uint8_t flags)
{
800033d8:	fe010113          	addi	sp,sp,-32
800033dc:	00812e23          	sw	s0,28(sp)
800033e0:	02010413          	addi	s0,sp,32
800033e4:	fea42623          	sw	a0,-20(s0)
800033e8:	00058793          	mv	a5,a1
800033ec:	fef405a3          	sb	a5,-21(s0)
	page->flags |= flags;
800033f0:	fec42783          	lw	a5,-20(s0)
800033f4:	0007c703          	lbu	a4,0(a5)
800033f8:	feb44783          	lbu	a5,-21(s0)
800033fc:	00f767b3          	or	a5,a4,a5
80003400:	0ff7f713          	andi	a4,a5,255
80003404:	fec42783          	lw	a5,-20(s0)
80003408:	00e78023          	sb	a4,0(a5)
}
8000340c:	00000013          	nop
80003410:	01c12403          	lw	s0,28(sp)
80003414:	02010113          	addi	sp,sp,32
80003418:	00008067          	ret

8000341c <_is_last>:

static inline int _is_last(struct Page *page)
{
8000341c:	fe010113          	addi	sp,sp,-32
80003420:	00812e23          	sw	s0,28(sp)
80003424:	02010413          	addi	s0,sp,32
80003428:	fea42623          	sw	a0,-20(s0)
	if (page->flags & PAGE_LAST) {
8000342c:	fec42783          	lw	a5,-20(s0)
80003430:	0007c783          	lbu	a5,0(a5)
80003434:	0027f793          	andi	a5,a5,2
80003438:	00078663          	beqz	a5,80003444 <_is_last+0x28>
		return 1;
8000343c:	00100793          	li	a5,1
80003440:	0080006f          	j	80003448 <_is_last+0x2c>
	} else {
		return 0;
80003444:	00000793          	li	a5,0
	}
}
80003448:	00078513          	mv	a0,a5
8000344c:	01c12403          	lw	s0,28(sp)
80003450:	02010113          	addi	sp,sp,32
80003454:	00008067          	ret

80003458 <_align_page>:

/*
 * align the address to the border of page(4K)
 */
static inline uint32_t _align_page(uint32_t address)
{
80003458:	fd010113          	addi	sp,sp,-48
8000345c:	02812623          	sw	s0,44(sp)
80003460:	03010413          	addi	s0,sp,48
80003464:	fca42e23          	sw	a0,-36(s0)
	uint32_t order = (1 << PAGE_ORDER) - 1;
80003468:	000017b7          	lui	a5,0x1
8000346c:	fff78793          	addi	a5,a5,-1 # fff <STACK_SIZE+0xbff>
80003470:	fef42623          	sw	a5,-20(s0)
	return (address + order) & (~order);
80003474:	fdc42703          	lw	a4,-36(s0)
80003478:	fec42783          	lw	a5,-20(s0)
8000347c:	00f70733          	add	a4,a4,a5
80003480:	fec42783          	lw	a5,-20(s0)
80003484:	fff7c793          	not	a5,a5
80003488:	00f777b3          	and	a5,a4,a5
}
8000348c:	00078513          	mv	a0,a5
80003490:	02c12403          	lw	s0,44(sp)
80003494:	03010113          	addi	sp,sp,48
80003498:	00008067          	ret

8000349c <page_init>:

void page_init()
{
8000349c:	fe010113          	addi	sp,sp,-32
800034a0:	00112e23          	sw	ra,28(sp)
800034a4:	00812c23          	sw	s0,24(sp)
800034a8:	02010413          	addi	s0,sp,32
	/* 
	 * We reserved 8 Page (8 x 4096) to hold the Page structures.
	 * It should be enough to manage at most 128 MB (8 x 4096 x 4096) 
	 */
	_num_pages = (HEAP_SIZE / PAGE_SIZE) - 8;
800034ac:	800057b7          	lui	a5,0x80005
800034b0:	6647a783          	lw	a5,1636(a5) # 80005664 <_memory_end+0xf8005664>
800034b4:	00c7d793          	srli	a5,a5,0xc
800034b8:	ff878713          	addi	a4,a5,-8
800034bc:	80b067b7          	lui	a5,0x80b06
800034c0:	70e7ac23          	sw	a4,1816(a5) # 80b06718 <_memory_end+0xf8b06718>
	printf("HEAP_START = %x, HEAP_SIZE = %x, num of pages = %d\n", HEAP_START, HEAP_SIZE, _num_pages);
800034c4:	800057b7          	lui	a5,0x80005
800034c8:	6607a703          	lw	a4,1632(a5) # 80005660 <_memory_end+0xf8005660>
800034cc:	800057b7          	lui	a5,0x80005
800034d0:	6647a603          	lw	a2,1636(a5) # 80005664 <_memory_end+0xf8005664>
800034d4:	80b067b7          	lui	a5,0x80b06
800034d8:	7187a783          	lw	a5,1816(a5) # 80b06718 <_memory_end+0xf8b06718>
800034dc:	00078693          	mv	a3,a5
800034e0:	00070593          	mv	a1,a4
800034e4:	800067b7          	lui	a5,0x80006
800034e8:	8bc78513          	addi	a0,a5,-1860 # 800058bc <_memory_end+0xf80058bc>
800034ec:	19d010ef          	jal	ra,80004e88 <printf>
	
	struct Page *page = (struct Page *)HEAP_START;
800034f0:	800057b7          	lui	a5,0x80005
800034f4:	6607a783          	lw	a5,1632(a5) # 80005660 <_memory_end+0xf8005660>
800034f8:	fef42623          	sw	a5,-20(s0)
	for (int i = 0; i < _num_pages; i++) {
800034fc:	fe042423          	sw	zero,-24(s0)
80003500:	0240006f          	j	80003524 <page_init+0x88>
		_clear(page);
80003504:	fec42503          	lw	a0,-20(s0)
80003508:	e6dff0ef          	jal	ra,80003374 <_clear>
		page++;	
8000350c:	fec42783          	lw	a5,-20(s0)
80003510:	00178793          	addi	a5,a5,1
80003514:	fef42623          	sw	a5,-20(s0)
	for (int i = 0; i < _num_pages; i++) {
80003518:	fe842783          	lw	a5,-24(s0)
8000351c:	00178793          	addi	a5,a5,1
80003520:	fef42423          	sw	a5,-24(s0)
80003524:	fe842703          	lw	a4,-24(s0)
80003528:	80b067b7          	lui	a5,0x80b06
8000352c:	7187a783          	lw	a5,1816(a5) # 80b06718 <_memory_end+0xf8b06718>
80003530:	fcf76ae3          	bltu	a4,a5,80003504 <page_init+0x68>
	}

	_alloc_start = _align_page(HEAP_START + 8 * PAGE_SIZE);
80003534:	800057b7          	lui	a5,0x80005
80003538:	6607a703          	lw	a4,1632(a5) # 80005660 <_memory_end+0xf8005660>
8000353c:	000087b7          	lui	a5,0x8
80003540:	00f707b3          	add	a5,a4,a5
80003544:	00078513          	mv	a0,a5
80003548:	f11ff0ef          	jal	ra,80003458 <_align_page>
8000354c:	00050713          	mv	a4,a0
80003550:	80b067b7          	lui	a5,0x80b06
80003554:	70e7a823          	sw	a4,1808(a5) # 80b06710 <_memory_end+0xf8b06710>
	_alloc_end = _alloc_start + (PAGE_SIZE * _num_pages);
80003558:	80b067b7          	lui	a5,0x80b06
8000355c:	7187a783          	lw	a5,1816(a5) # 80b06718 <_memory_end+0xf8b06718>
80003560:	00c79713          	slli	a4,a5,0xc
80003564:	80b067b7          	lui	a5,0x80b06
80003568:	7107a783          	lw	a5,1808(a5) # 80b06710 <_memory_end+0xf8b06710>
8000356c:	00f70733          	add	a4,a4,a5
80003570:	80b067b7          	lui	a5,0x80b06
80003574:	70e7aa23          	sw	a4,1812(a5) # 80b06714 <_memory_end+0xf8b06714>

	printf("TEXT:   0x%x -> 0x%x\n", TEXT_START, TEXT_END);
80003578:	800057b7          	lui	a5,0x80005
8000357c:	6687a703          	lw	a4,1640(a5) # 80005668 <_memory_end+0xf8005668>
80003580:	800057b7          	lui	a5,0x80005
80003584:	66c7a783          	lw	a5,1644(a5) # 8000566c <_memory_end+0xf800566c>
80003588:	00078613          	mv	a2,a5
8000358c:	00070593          	mv	a1,a4
80003590:	800067b7          	lui	a5,0x80006
80003594:	8f078513          	addi	a0,a5,-1808 # 800058f0 <_memory_end+0xf80058f0>
80003598:	0f1010ef          	jal	ra,80004e88 <printf>
	printf("RODATA: 0x%x -> 0x%x\n", RODATA_START, RODATA_END);
8000359c:	800057b7          	lui	a5,0x80005
800035a0:	6787a703          	lw	a4,1656(a5) # 80005678 <_memory_end+0xf8005678>
800035a4:	800057b7          	lui	a5,0x80005
800035a8:	67c7a783          	lw	a5,1660(a5) # 8000567c <_memory_end+0xf800567c>
800035ac:	00078613          	mv	a2,a5
800035b0:	00070593          	mv	a1,a4
800035b4:	800067b7          	lui	a5,0x80006
800035b8:	90878513          	addi	a0,a5,-1784 # 80005908 <_memory_end+0xf8005908>
800035bc:	0cd010ef          	jal	ra,80004e88 <printf>
	printf("DATA:   0x%x -> 0x%x\n", DATA_START, DATA_END);
800035c0:	800057b7          	lui	a5,0x80005
800035c4:	6707a703          	lw	a4,1648(a5) # 80005670 <_memory_end+0xf8005670>
800035c8:	800057b7          	lui	a5,0x80005
800035cc:	6747a783          	lw	a5,1652(a5) # 80005674 <_memory_end+0xf8005674>
800035d0:	00078613          	mv	a2,a5
800035d4:	00070593          	mv	a1,a4
800035d8:	800067b7          	lui	a5,0x80006
800035dc:	92078513          	addi	a0,a5,-1760 # 80005920 <_memory_end+0xf8005920>
800035e0:	0a9010ef          	jal	ra,80004e88 <printf>
	printf("BSS:    0x%x -> 0x%x\n", BSS_START, BSS_END);
800035e4:	800057b7          	lui	a5,0x80005
800035e8:	6807a703          	lw	a4,1664(a5) # 80005680 <_memory_end+0xf8005680>
800035ec:	800057b7          	lui	a5,0x80005
800035f0:	6847a783          	lw	a5,1668(a5) # 80005684 <_memory_end+0xf8005684>
800035f4:	00078613          	mv	a2,a5
800035f8:	00070593          	mv	a1,a4
800035fc:	800067b7          	lui	a5,0x80006
80003600:	93878513          	addi	a0,a5,-1736 # 80005938 <_memory_end+0xf8005938>
80003604:	085010ef          	jal	ra,80004e88 <printf>
	printf("HEAP:   0x%x -> 0x%x\n", _alloc_start, _alloc_end);
80003608:	80b067b7          	lui	a5,0x80b06
8000360c:	7107a703          	lw	a4,1808(a5) # 80b06710 <_memory_end+0xf8b06710>
80003610:	80b067b7          	lui	a5,0x80b06
80003614:	7147a783          	lw	a5,1812(a5) # 80b06714 <_memory_end+0xf8b06714>
80003618:	00078613          	mv	a2,a5
8000361c:	00070593          	mv	a1,a4
80003620:	800067b7          	lui	a5,0x80006
80003624:	95078513          	addi	a0,a5,-1712 # 80005950 <_memory_end+0xf8005950>
80003628:	061010ef          	jal	ra,80004e88 <printf>
}
8000362c:	00000013          	nop
80003630:	01c12083          	lw	ra,28(sp)
80003634:	01812403          	lw	s0,24(sp)
80003638:	02010113          	addi	sp,sp,32
8000363c:	00008067          	ret

80003640 <page_alloc>:
/*
 * Allocate a memory block which is composed of contiguous physical pages
 * - npages: the number of PAGE_SIZE pages to allocate
 */
void *page_alloc(int npages)
{
80003640:	fc010113          	addi	sp,sp,-64
80003644:	02112e23          	sw	ra,60(sp)
80003648:	02812c23          	sw	s0,56(sp)
8000364c:	04010413          	addi	s0,sp,64
80003650:	fca42623          	sw	a0,-52(s0)
	/* Note we are searching the page descriptor bitmaps. */
	int found = 0;
80003654:	fe042623          	sw	zero,-20(s0)
	struct Page *page_i = (struct Page *)HEAP_START;
80003658:	800057b7          	lui	a5,0x80005
8000365c:	6607a783          	lw	a5,1632(a5) # 80005660 <_memory_end+0xf8005660>
80003660:	fef42423          	sw	a5,-24(s0)
	for (int i = 0; i <= (_num_pages - npages); i++) {
80003664:	fe042223          	sw	zero,-28(s0)
80003668:	11c0006f          	j	80003784 <page_alloc+0x144>
		if (_is_free(page_i)) {
8000366c:	fe842503          	lw	a0,-24(s0)
80003670:	d2dff0ef          	jal	ra,8000339c <_is_free>
80003674:	00050793          	mv	a5,a0
80003678:	0e078a63          	beqz	a5,8000376c <page_alloc+0x12c>
			found = 1;
8000367c:	00100793          	li	a5,1
80003680:	fef42623          	sw	a5,-20(s0)
			/* 
			 * meet a free page, continue to check if following
			 * (npages - 1) pages are also unallocated.
			 */
			struct Page *page_j = page_i + 1;
80003684:	fe842783          	lw	a5,-24(s0)
80003688:	00178793          	addi	a5,a5,1
8000368c:	fef42023          	sw	a5,-32(s0)
			for (int j = i + 1; j < (i + npages); j++) {
80003690:	fe442783          	lw	a5,-28(s0)
80003694:	00178793          	addi	a5,a5,1
80003698:	fcf42e23          	sw	a5,-36(s0)
8000369c:	0340006f          	j	800036d0 <page_alloc+0x90>
				if (!_is_free(page_j)) {
800036a0:	fe042503          	lw	a0,-32(s0)
800036a4:	cf9ff0ef          	jal	ra,8000339c <_is_free>
800036a8:	00050793          	mv	a5,a0
800036ac:	00079663          	bnez	a5,800036b8 <page_alloc+0x78>
					found = 0;
800036b0:	fe042623          	sw	zero,-20(s0)
					break;
800036b4:	0300006f          	j	800036e4 <page_alloc+0xa4>
				}
				page_j++;
800036b8:	fe042783          	lw	a5,-32(s0)
800036bc:	00178793          	addi	a5,a5,1
800036c0:	fef42023          	sw	a5,-32(s0)
			for (int j = i + 1; j < (i + npages); j++) {
800036c4:	fdc42783          	lw	a5,-36(s0)
800036c8:	00178793          	addi	a5,a5,1
800036cc:	fcf42e23          	sw	a5,-36(s0)
800036d0:	fe442703          	lw	a4,-28(s0)
800036d4:	fcc42783          	lw	a5,-52(s0)
800036d8:	00f707b3          	add	a5,a4,a5
800036dc:	fdc42703          	lw	a4,-36(s0)
800036e0:	fcf740e3          	blt	a4,a5,800036a0 <page_alloc+0x60>
			/*
			 * get a memory block which is good enough for us,
			 * take housekeeping, then return the actual start
			 * address of the first page of this memory block
			 */
			if (found) {
800036e4:	fec42783          	lw	a5,-20(s0)
800036e8:	08078263          	beqz	a5,8000376c <page_alloc+0x12c>
				struct Page *page_k = page_i;
800036ec:	fe842783          	lw	a5,-24(s0)
800036f0:	fcf42c23          	sw	a5,-40(s0)
				for (int k = i; k < (i + npages); k++) {
800036f4:	fe442783          	lw	a5,-28(s0)
800036f8:	fcf42a23          	sw	a5,-44(s0)
800036fc:	0280006f          	j	80003724 <page_alloc+0xe4>
					_set_flag(page_k, PAGE_TAKEN);
80003700:	00100593          	li	a1,1
80003704:	fd842503          	lw	a0,-40(s0)
80003708:	cd1ff0ef          	jal	ra,800033d8 <_set_flag>
					page_k++;
8000370c:	fd842783          	lw	a5,-40(s0)
80003710:	00178793          	addi	a5,a5,1
80003714:	fcf42c23          	sw	a5,-40(s0)
				for (int k = i; k < (i + npages); k++) {
80003718:	fd442783          	lw	a5,-44(s0)
8000371c:	00178793          	addi	a5,a5,1
80003720:	fcf42a23          	sw	a5,-44(s0)
80003724:	fe442703          	lw	a4,-28(s0)
80003728:	fcc42783          	lw	a5,-52(s0)
8000372c:	00f707b3          	add	a5,a4,a5
80003730:	fd442703          	lw	a4,-44(s0)
80003734:	fcf746e3          	blt	a4,a5,80003700 <page_alloc+0xc0>
				}
				page_k--;
80003738:	fd842783          	lw	a5,-40(s0)
8000373c:	fff78793          	addi	a5,a5,-1
80003740:	fcf42c23          	sw	a5,-40(s0)
				_set_flag(page_k, PAGE_LAST);
80003744:	00200593          	li	a1,2
80003748:	fd842503          	lw	a0,-40(s0)
8000374c:	c8dff0ef          	jal	ra,800033d8 <_set_flag>
				return (void *)(_alloc_start + i * PAGE_SIZE);
80003750:	fe442783          	lw	a5,-28(s0)
80003754:	00c79793          	slli	a5,a5,0xc
80003758:	00078713          	mv	a4,a5
8000375c:	80b067b7          	lui	a5,0x80b06
80003760:	7107a783          	lw	a5,1808(a5) # 80b06710 <_memory_end+0xf8b06710>
80003764:	00f707b3          	add	a5,a4,a5
80003768:	0380006f          	j	800037a0 <page_alloc+0x160>
			}
		}
		page_i++;
8000376c:	fe842783          	lw	a5,-24(s0)
80003770:	00178793          	addi	a5,a5,1
80003774:	fef42423          	sw	a5,-24(s0)
	for (int i = 0; i <= (_num_pages - npages); i++) {
80003778:	fe442783          	lw	a5,-28(s0)
8000377c:	00178793          	addi	a5,a5,1
80003780:	fef42223          	sw	a5,-28(s0)
80003784:	80b067b7          	lui	a5,0x80b06
80003788:	7187a703          	lw	a4,1816(a5) # 80b06718 <_memory_end+0xf8b06718>
8000378c:	fcc42783          	lw	a5,-52(s0)
80003790:	40f70733          	sub	a4,a4,a5
80003794:	fe442783          	lw	a5,-28(s0)
80003798:	ecf77ae3          	bgeu	a4,a5,8000366c <page_alloc+0x2c>
	}
	return NULL;
8000379c:	00000793          	li	a5,0
}
800037a0:	00078513          	mv	a0,a5
800037a4:	03c12083          	lw	ra,60(sp)
800037a8:	03812403          	lw	s0,56(sp)
800037ac:	04010113          	addi	sp,sp,64
800037b0:	00008067          	ret

800037b4 <page_free>:
/*
 * Free the memory block
 * - p: start address of the memory block
 */
void page_free(void *p)
{
800037b4:	fd010113          	addi	sp,sp,-48
800037b8:	02112623          	sw	ra,44(sp)
800037bc:	02812423          	sw	s0,40(sp)
800037c0:	03010413          	addi	s0,sp,48
800037c4:	fca42e23          	sw	a0,-36(s0)
	/*
	 * Assert (TBD) if p is invalid
	 */
	if (!p || (uint32_t)p >= _alloc_end) {
800037c8:	fdc42783          	lw	a5,-36(s0)
800037cc:	08078463          	beqz	a5,80003854 <page_free+0xa0>
800037d0:	fdc42703          	lw	a4,-36(s0)
800037d4:	80b067b7          	lui	a5,0x80b06
800037d8:	7147a783          	lw	a5,1812(a5) # 80b06714 <_memory_end+0xf8b06714>
800037dc:	06f77c63          	bgeu	a4,a5,80003854 <page_free+0xa0>
		return;
	}
	/* get the first page descriptor of this memory block */
	struct Page *page = (struct Page *)HEAP_START;
800037e0:	800057b7          	lui	a5,0x80005
800037e4:	6607a783          	lw	a5,1632(a5) # 80005660 <_memory_end+0xf8005660>
800037e8:	fef42623          	sw	a5,-20(s0)
	page += ((uint32_t)p - _alloc_start)/ PAGE_SIZE;
800037ec:	fdc42703          	lw	a4,-36(s0)
800037f0:	80b067b7          	lui	a5,0x80b06
800037f4:	7107a783          	lw	a5,1808(a5) # 80b06710 <_memory_end+0xf8b06710>
800037f8:	40f707b3          	sub	a5,a4,a5
800037fc:	00c7d793          	srli	a5,a5,0xc
80003800:	fec42703          	lw	a4,-20(s0)
80003804:	00f707b3          	add	a5,a4,a5
80003808:	fef42623          	sw	a5,-20(s0)
	/* loop and clear all the page descriptors of the memory block */
	while (!_is_free(page)) {
8000380c:	0340006f          	j	80003840 <page_free+0x8c>
		if (_is_last(page)) {
80003810:	fec42503          	lw	a0,-20(s0)
80003814:	c09ff0ef          	jal	ra,8000341c <_is_last>
80003818:	00050793          	mv	a5,a0
8000381c:	00078863          	beqz	a5,8000382c <page_free+0x78>
			_clear(page);
80003820:	fec42503          	lw	a0,-20(s0)
80003824:	b51ff0ef          	jal	ra,80003374 <_clear>
			break;
80003828:	0300006f          	j	80003858 <page_free+0xa4>
		} else {
			_clear(page);
8000382c:	fec42503          	lw	a0,-20(s0)
80003830:	b45ff0ef          	jal	ra,80003374 <_clear>
			page++;;
80003834:	fec42783          	lw	a5,-20(s0)
80003838:	00178793          	addi	a5,a5,1
8000383c:	fef42623          	sw	a5,-20(s0)
	while (!_is_free(page)) {
80003840:	fec42503          	lw	a0,-20(s0)
80003844:	b59ff0ef          	jal	ra,8000339c <_is_free>
80003848:	00050793          	mv	a5,a0
8000384c:	fc0782e3          	beqz	a5,80003810 <page_free+0x5c>
80003850:	0080006f          	j	80003858 <page_free+0xa4>
		return;
80003854:	00000013          	nop
		}
	}
}
80003858:	02c12083          	lw	ra,44(sp)
8000385c:	02812403          	lw	s0,40(sp)
80003860:	03010113          	addi	sp,sp,48
80003864:	00008067          	ret

80003868 <page_test>:

void page_test()
{
80003868:	fe010113          	addi	sp,sp,-32
8000386c:	00112e23          	sw	ra,28(sp)
80003870:	00812c23          	sw	s0,24(sp)
80003874:	02010413          	addi	s0,sp,32
	void *p = page_alloc(2);
80003878:	00200513          	li	a0,2
8000387c:	dc5ff0ef          	jal	ra,80003640 <page_alloc>
80003880:	fea42623          	sw	a0,-20(s0)
	printf("p = 0x%x\n", p);
80003884:	fec42583          	lw	a1,-20(s0)
80003888:	800067b7          	lui	a5,0x80006
8000388c:	96878513          	addi	a0,a5,-1688 # 80005968 <_memory_end+0xf8005968>
80003890:	5f8010ef          	jal	ra,80004e88 <printf>
	//page_free(p);

	void *p2 = page_alloc(7);
80003894:	00700513          	li	a0,7
80003898:	da9ff0ef          	jal	ra,80003640 <page_alloc>
8000389c:	fea42423          	sw	a0,-24(s0)
	printf("p2 = 0x%x\n", p2);
800038a0:	fe842583          	lw	a1,-24(s0)
800038a4:	800067b7          	lui	a5,0x80006
800038a8:	97478513          	addi	a0,a5,-1676 # 80005974 <_memory_end+0xf8005974>
800038ac:	5dc010ef          	jal	ra,80004e88 <printf>
	page_free(p2);
800038b0:	fe842503          	lw	a0,-24(s0)
800038b4:	f01ff0ef          	jal	ra,800037b4 <page_free>

	void *p3 = page_alloc(4);
800038b8:	00400513          	li	a0,4
800038bc:	d85ff0ef          	jal	ra,80003640 <page_alloc>
800038c0:	fea42223          	sw	a0,-28(s0)
	printf("p3 = 0x%x\n", p3);
800038c4:	fe442583          	lw	a1,-28(s0)
800038c8:	800067b7          	lui	a5,0x80006
800038cc:	98078513          	addi	a0,a5,-1664 # 80005980 <_memory_end+0xf8005980>
800038d0:	5b8010ef          	jal	ra,80004e88 <printf>
}
800038d4:	00000013          	nop
800038d8:	01c12083          	lw	ra,28(sp)
800038dc:	01812403          	lw	s0,24(sp)
800038e0:	02010113          	addi	sp,sp,32
800038e4:	00008067          	ret

800038e8 <memset>:

static char memory_pool[MEMORY_POOL_SIZE];
static mem_block *free_list = (void *)memory_pool;

void *memset(void *ptr, int value, size_t num)
{
800038e8:	fd010113          	addi	sp,sp,-48
800038ec:	02812623          	sw	s0,44(sp)
800038f0:	03010413          	addi	s0,sp,48
800038f4:	fca42e23          	sw	a0,-36(s0)
800038f8:	fcb42c23          	sw	a1,-40(s0)
800038fc:	fcc42a23          	sw	a2,-44(s0)
    unsigned char *p = ptr;
80003900:	fdc42783          	lw	a5,-36(s0)
80003904:	fef42623          	sw	a5,-20(s0)
    while (num--)
80003908:	01c0006f          	j	80003924 <memset+0x3c>
    {
        *p++ = (unsigned char)value;
8000390c:	fec42783          	lw	a5,-20(s0)
80003910:	00178713          	addi	a4,a5,1
80003914:	fee42623          	sw	a4,-20(s0)
80003918:	fd842703          	lw	a4,-40(s0)
8000391c:	0ff77713          	andi	a4,a4,255
80003920:	00e78023          	sb	a4,0(a5)
    while (num--)
80003924:	fd442783          	lw	a5,-44(s0)
80003928:	fff78713          	addi	a4,a5,-1
8000392c:	fce42a23          	sw	a4,-44(s0)
80003930:	fc079ee3          	bnez	a5,8000390c <memset+0x24>
    }
    return ptr;
80003934:	fdc42783          	lw	a5,-36(s0)
}
80003938:	00078513          	mv	a0,a5
8000393c:	02c12403          	lw	s0,44(sp)
80003940:	03010113          	addi	sp,sp,48
80003944:	00008067          	ret

80003948 <memory_init>:

void memory_init(void)
{
80003948:	ff010113          	addi	sp,sp,-16
8000394c:	00812623          	sw	s0,12(sp)
80003950:	01010413          	addi	s0,sp,16
    free_list->size = MEMORY_POOL_SIZE - sizeof(mem_block);
80003954:	800067b7          	lui	a5,0x80006
80003958:	0047a783          	lw	a5,4(a5) # 80006004 <_memory_end+0xf8006004>
8000395c:	00100737          	lui	a4,0x100
80003960:	ff470713          	addi	a4,a4,-12 # ffff4 <STACK_SIZE+0xffbf4>
80003964:	00e7a023          	sw	a4,0(a5)
    free_list->next = NULL;
80003968:	800067b7          	lui	a5,0x80006
8000396c:	0047a783          	lw	a5,4(a5) # 80006004 <_memory_end+0xf8006004>
80003970:	0007a223          	sw	zero,4(a5)
    free_list->free = 1;
80003974:	800067b7          	lui	a5,0x80006
80003978:	0047a783          	lw	a5,4(a5) # 80006004 <_memory_end+0xf8006004>
8000397c:	00100713          	li	a4,1
80003980:	00e7a423          	sw	a4,8(a5)
}
80003984:	00000013          	nop
80003988:	00c12403          	lw	s0,12(sp)
8000398c:	01010113          	addi	sp,sp,16
80003990:	00008067          	ret

80003994 <malloc>:

void *malloc(size_t size)
{
80003994:	fc010113          	addi	sp,sp,-64
80003998:	02112e23          	sw	ra,60(sp)
8000399c:	02812c23          	sw	s0,56(sp)
800039a0:	04010413          	addi	s0,sp,64
800039a4:	fca42623          	sw	a0,-52(s0)
    size_t best_fit_size = MEMORY_POOL_SIZE;
800039a8:	001007b7          	lui	a5,0x100
800039ac:	fef42623          	sw	a5,-20(s0)
    mem_block *best_fit_block = NULL;
800039b0:	fe042423          	sw	zero,-24(s0)
    mem_block *current = free_list;
800039b4:	800067b7          	lui	a5,0x80006
800039b8:	0047a783          	lw	a5,4(a5) # 80006004 <_memory_end+0xf8006004>
800039bc:	fef42223          	sw	a5,-28(s0)

    size = ALIGN(size + sizeof(mem_block)); // 包括管理结构的大小
800039c0:	fcc42783          	lw	a5,-52(s0)
800039c4:	01b78793          	addi	a5,a5,27
800039c8:	ff07f793          	andi	a5,a5,-16
800039cc:	fcf42623          	sw	a5,-52(s0)

    // printf("请求分配 %d 字节的内存\n", size);

    while (current)
800039d0:	05c0006f          	j	80003a2c <malloc+0x98>
    {
        // printf("检查块：地址=%p，大小=%d\n", (void *)current, current->size);
        if (current->free && current->size >= size)
800039d4:	fe442783          	lw	a5,-28(s0)
800039d8:	0087a783          	lw	a5,8(a5)
800039dc:	04078263          	beqz	a5,80003a20 <malloc+0x8c>
800039e0:	fe442783          	lw	a5,-28(s0)
800039e4:	0007a783          	lw	a5,0(a5)
800039e8:	fcc42703          	lw	a4,-52(s0)
800039ec:	02e7ea63          	bltu	a5,a4,80003a20 <malloc+0x8c>
        {
            size_t current_block_free_space = current->size - size;
800039f0:	fe442783          	lw	a5,-28(s0)
800039f4:	0007a703          	lw	a4,0(a5)
800039f8:	fcc42783          	lw	a5,-52(s0)
800039fc:	40f707b3          	sub	a5,a4,a5
80003a00:	fcf42c23          	sw	a5,-40(s0)
            if (current_block_free_space < best_fit_size)
80003a04:	fd842703          	lw	a4,-40(s0)
80003a08:	fec42783          	lw	a5,-20(s0)
80003a0c:	00f77a63          	bgeu	a4,a5,80003a20 <malloc+0x8c>
            {
                best_fit_size = current_block_free_space;
80003a10:	fd842783          	lw	a5,-40(s0)
80003a14:	fef42623          	sw	a5,-20(s0)
                best_fit_block = current;
80003a18:	fe442783          	lw	a5,-28(s0)
80003a1c:	fef42423          	sw	a5,-24(s0)
            }
        }
        current = current->next;
80003a20:	fe442783          	lw	a5,-28(s0)
80003a24:	0047a783          	lw	a5,4(a5)
80003a28:	fef42223          	sw	a5,-28(s0)
    while (current)
80003a2c:	fe442783          	lw	a5,-28(s0)
80003a30:	fa0792e3          	bnez	a5,800039d4 <malloc+0x40>
        // printf("移动到下一个块：地址=%p\n", (void *)current);
    }

    if (!best_fit_block)
80003a34:	fe842783          	lw	a5,-24(s0)
80003a38:	00079e63          	bnez	a5,80003a54 <malloc+0xc0>
    {
        printf("错误：没有足够的空间分配 %d 字节的内存\n", size);
80003a3c:	fcc42583          	lw	a1,-52(s0)
80003a40:	800067b7          	lui	a5,0x80006
80003a44:	98c78513          	addi	a0,a5,-1652 # 8000598c <_memory_end+0xf800598c>
80003a48:	440010ef          	jal	ra,80004e88 <printf>
        return NULL; // 没有足够的空间
80003a4c:	00000793          	li	a5,0
80003a50:	0b80006f          	j	80003b08 <malloc+0x174>
    }

    if (best_fit_size <= sizeof(mem_block) + MIN_BLOCK_SIZE)
80003a54:	fec42703          	lw	a4,-20(s0)
80003a58:	02c00793          	li	a5,44
80003a5c:	00e7ec63          	bltu	a5,a4,80003a74 <malloc+0xe0>
    {
        // 如果剩余空间不足以创建一个新的mem_block，则不分割，直接分配整个块
        best_fit_block->free = 0;
80003a60:	fe842783          	lw	a5,-24(s0)
80003a64:	0007a423          	sw	zero,8(a5)
        best_fit_block->next = NULL;
80003a68:	fe842783          	lw	a5,-24(s0)
80003a6c:	0007a223          	sw	zero,4(a5)
80003a70:	06c0006f          	j	80003adc <malloc+0x148>
    }
    else
    {
        // 分割内存块
        mem_block *new_block = (mem_block *)((char *)best_fit_block + size);
80003a74:	fe842703          	lw	a4,-24(s0)
80003a78:	fcc42783          	lw	a5,-52(s0)
80003a7c:	00f707b3          	add	a5,a4,a5
80003a80:	fef42023          	sw	a5,-32(s0)
        new_block->size = best_fit_block->size - size;
80003a84:	fe842783          	lw	a5,-24(s0)
80003a88:	0007a703          	lw	a4,0(a5)
80003a8c:	fcc42783          	lw	a5,-52(s0)
80003a90:	40f70733          	sub	a4,a4,a5
80003a94:	fe042783          	lw	a5,-32(s0)
80003a98:	00e7a023          	sw	a4,0(a5)
        new_block->next = best_fit_block->next;
80003a9c:	fe842783          	lw	a5,-24(s0)
80003aa0:	0047a703          	lw	a4,4(a5)
80003aa4:	fe042783          	lw	a5,-32(s0)
80003aa8:	00e7a223          	sw	a4,4(a5)
        new_block->free = 1;
80003aac:	fe042783          	lw	a5,-32(s0)
80003ab0:	00100713          	li	a4,1
80003ab4:	00e7a423          	sw	a4,8(a5)

        best_fit_block->size = size - sizeof(mem_block); // 更新当前块的大小，减去管理结构的大小
80003ab8:	fcc42783          	lw	a5,-52(s0)
80003abc:	ff478713          	addi	a4,a5,-12
80003ac0:	fe842783          	lw	a5,-24(s0)
80003ac4:	00e7a023          	sw	a4,0(a5)
        best_fit_block->free = 0;
80003ac8:	fe842783          	lw	a5,-24(s0)
80003acc:	0007a423          	sw	zero,8(a5)
        best_fit_block->next = new_block;
80003ad0:	fe842783          	lw	a5,-24(s0)
80003ad4:	fe042703          	lw	a4,-32(s0)
80003ad8:	00e7a223          	sw	a4,4(a5)
    }

    // 初始化分配的内存块（不包括管理结构）
    void *allocated_memory = (void *)(best_fit_block + 1);
80003adc:	fe842783          	lw	a5,-24(s0)
80003ae0:	00c78793          	addi	a5,a5,12
80003ae4:	fcf42e23          	sw	a5,-36(s0)
    memset(allocated_memory, 0, best_fit_block->size - sizeof(mem_block));
80003ae8:	fe842783          	lw	a5,-24(s0)
80003aec:	0007a783          	lw	a5,0(a5)
80003af0:	ff478793          	addi	a5,a5,-12
80003af4:	00078613          	mv	a2,a5
80003af8:	00000593          	li	a1,0
80003afc:	fdc42503          	lw	a0,-36(s0)
80003b00:	de9ff0ef          	jal	ra,800038e8 <memset>

    // printf("分配了 %d 字节的内存\n", size);
    // printf("分配后块：地址=%p，大小=%d\n", (void *)best_fit_block, best_fit_block->size);
    // printf("新块：地址=%p，大小=%d\n\n", (void *)best_fit_block->next, best_fit_block->next ? best_fit_block->next->size : 0);
    return allocated_memory;
80003b04:	fdc42783          	lw	a5,-36(s0)
}
80003b08:	00078513          	mv	a0,a5
80003b0c:	03c12083          	lw	ra,60(sp)
80003b10:	03812403          	lw	s0,56(sp)
80003b14:	04010113          	addi	sp,sp,64
80003b18:	00008067          	ret

80003b1c <free>:

void free(void *ptr)
{
80003b1c:	fd010113          	addi	sp,sp,-48
80003b20:	02112623          	sw	ra,44(sp)
80003b24:	02812423          	sw	s0,40(sp)
80003b28:	03010413          	addi	s0,sp,48
80003b2c:	fca42e23          	sw	a0,-36(s0)
    if (!ptr)
80003b30:	fdc42783          	lw	a5,-36(s0)
80003b34:	00079a63          	bnez	a5,80003b48 <free+0x2c>
    {
        printf("警告：尝试释放NULL指针\n");
80003b38:	800067b7          	lui	a5,0x80006
80003b3c:	9c878513          	addi	a0,a5,-1592 # 800059c8 <_memory_end+0xf80059c8>
80003b40:	348010ef          	jal	ra,80004e88 <printf>
        return;
80003b44:	1040006f          	j	80003c48 <free+0x12c>
    }
    mem_block *block_to_free = (mem_block *)((char *)ptr - sizeof(mem_block));
80003b48:	fdc42783          	lw	a5,-36(s0)
80003b4c:	ff478793          	addi	a5,a5,-12
80003b50:	fef42223          	sw	a5,-28(s0)
    block_to_free->free = 1;
80003b54:	fe442783          	lw	a5,-28(s0)
80003b58:	00100713          	li	a4,1
80003b5c:	00e7a423          	sw	a4,8(a5)

    // printf("释放块：地址=%p，大小=%d\n\n", (void *)block_to_free, block_to_free->size);

    // 合并空闲块
    mem_block *current = free_list;
80003b60:	800067b7          	lui	a5,0x80006
80003b64:	0047a783          	lw	a5,4(a5) # 80006004 <_memory_end+0xf8006004>
80003b68:	fef42623          	sw	a5,-20(s0)
    mem_block *prev = NULL;
80003b6c:	fe042423          	sw	zero,-24(s0)
    while (current)
80003b70:	0c80006f          	j	80003c38 <free+0x11c>
    {
        if (current == block_to_free)
80003b74:	fec42703          	lw	a4,-20(s0)
80003b78:	fe442783          	lw	a5,-28(s0)
80003b7c:	0af71463          	bne	a4,a5,80003c24 <free+0x108>
        {
            // 如果前一个块是空闲的，则合并
            if (prev && prev->free)
80003b80:	fe842783          	lw	a5,-24(s0)
80003b84:	04078463          	beqz	a5,80003bcc <free+0xb0>
80003b88:	fe842783          	lw	a5,-24(s0)
80003b8c:	0087a783          	lw	a5,8(a5)
80003b90:	02078e63          	beqz	a5,80003bcc <free+0xb0>
            {
                prev->size += current->size + sizeof(mem_block);
80003b94:	fe842783          	lw	a5,-24(s0)
80003b98:	0007a703          	lw	a4,0(a5)
80003b9c:	fec42783          	lw	a5,-20(s0)
80003ba0:	0007a783          	lw	a5,0(a5)
80003ba4:	00f707b3          	add	a5,a4,a5
80003ba8:	00c78713          	addi	a4,a5,12
80003bac:	fe842783          	lw	a5,-24(s0)
80003bb0:	00e7a023          	sw	a4,0(a5)
                prev->next = current->next;
80003bb4:	fec42783          	lw	a5,-20(s0)
80003bb8:	0047a703          	lw	a4,4(a5)
80003bbc:	fe842783          	lw	a5,-24(s0)
80003bc0:	00e7a223          	sw	a4,4(a5)
                current = prev; // 更新当前指针以指向合并后的块
80003bc4:	fe842783          	lw	a5,-24(s0)
80003bc8:	fef42623          	sw	a5,-20(s0)
            }
            // 检查并合并下一个空闲块
            if (current->next && current->next->free)
80003bcc:	fec42783          	lw	a5,-20(s0)
80003bd0:	0047a783          	lw	a5,4(a5)
80003bd4:	06078863          	beqz	a5,80003c44 <free+0x128>
80003bd8:	fec42783          	lw	a5,-20(s0)
80003bdc:	0047a783          	lw	a5,4(a5)
80003be0:	0087a783          	lw	a5,8(a5)
80003be4:	06078063          	beqz	a5,80003c44 <free+0x128>
            {
                current->size += current->next->size + sizeof(mem_block);
80003be8:	fec42783          	lw	a5,-20(s0)
80003bec:	0007a703          	lw	a4,0(a5)
80003bf0:	fec42783          	lw	a5,-20(s0)
80003bf4:	0047a783          	lw	a5,4(a5)
80003bf8:	0007a783          	lw	a5,0(a5)
80003bfc:	00f707b3          	add	a5,a4,a5
80003c00:	00c78713          	addi	a4,a5,12
80003c04:	fec42783          	lw	a5,-20(s0)
80003c08:	00e7a023          	sw	a4,0(a5)
                current->next = current->next->next;
80003c0c:	fec42783          	lw	a5,-20(s0)
80003c10:	0047a783          	lw	a5,4(a5)
80003c14:	0047a703          	lw	a4,4(a5)
80003c18:	fec42783          	lw	a5,-20(s0)
80003c1c:	00e7a223          	sw	a4,4(a5)
            }
            break;
80003c20:	0240006f          	j	80003c44 <free+0x128>
        }
        prev = current;
80003c24:	fec42783          	lw	a5,-20(s0)
80003c28:	fef42423          	sw	a5,-24(s0)
        current = current->next;
80003c2c:	fec42783          	lw	a5,-20(s0)
80003c30:	0047a783          	lw	a5,4(a5)
80003c34:	fef42623          	sw	a5,-20(s0)
    while (current)
80003c38:	fec42783          	lw	a5,-20(s0)
80003c3c:	f2079ce3          	bnez	a5,80003b74 <free+0x58>
80003c40:	0080006f          	j	80003c48 <free+0x12c>
            break;
80003c44:	00000013          	nop
    }
}
80003c48:	02c12083          	lw	ra,44(sp)
80003c4c:	02812403          	lw	s0,40(sp)
80003c50:	03010113          	addi	sp,sp,48
80003c54:	00008067          	ret

80003c58 <print_blocks>:

void print_blocks(void)
{
80003c58:	fe010113          	addi	sp,sp,-32
80003c5c:	00112e23          	sw	ra,28(sp)
80003c60:	00812c23          	sw	s0,24(sp)
80003c64:	02010413          	addi	s0,sp,32
    void *block_ptr = memory_pool;
80003c68:	80b067b7          	lui	a5,0x80b06
80003c6c:	71c78793          	addi	a5,a5,1820 # 80b0671c <_memory_end+0xf8b0671c>
80003c70:	fef42623          	sw	a5,-20(s0)
    printf("-- start to print blocks --\n");
80003c74:	800067b7          	lui	a5,0x80006
80003c78:	9ec78513          	addi	a0,a5,-1556 # 800059ec <_memory_end+0xf80059ec>
80003c7c:	20c010ef          	jal	ra,80004e88 <printf>
    do
    {
        printf("\tblock: %p, size: %d, used: %d\n", block_ptr,
80003c80:	fec42783          	lw	a5,-20(s0)
80003c84:	0007a703          	lw	a4,0(a5)
               block_get_size(block_ptr), block_is_used(block_ptr));
80003c88:	fec42783          	lw	a5,-20(s0)
80003c8c:	0087a783          	lw	a5,8(a5)
        printf("\tblock: %p, size: %d, used: %d\n", block_ptr,
80003c90:	0017b793          	seqz	a5,a5
80003c94:	0ff7f793          	andi	a5,a5,255
80003c98:	00078693          	mv	a3,a5
80003c9c:	00070613          	mv	a2,a4
80003ca0:	fec42583          	lw	a1,-20(s0)
80003ca4:	800067b7          	lui	a5,0x80006
80003ca8:	a0c78513          	addi	a0,a5,-1524 # 80005a0c <_memory_end+0xf8005a0c>
80003cac:	1dc010ef          	jal	ra,80004e88 <printf>
        block_ptr = block_get_next(block_ptr);
80003cb0:	fec42783          	lw	a5,-20(s0)
80003cb4:	0047a783          	lw	a5,4(a5)
80003cb8:	fef42623          	sw	a5,-20(s0)
    } while (block_ptr);
80003cbc:	fec42783          	lw	a5,-20(s0)
80003cc0:	fc0790e3          	bnez	a5,80003c80 <print_blocks+0x28>
    printf("-- end to print blocks --\n");
80003cc4:	800067b7          	lui	a5,0x80006
80003cc8:	a2c78513          	addi	a0,a5,-1492 # 80005a2c <_memory_end+0xf8005a2c>
80003ccc:	1bc010ef          	jal	ra,80004e88 <printf>
}
80003cd0:	00000013          	nop
80003cd4:	01c12083          	lw	ra,28(sp)
80003cd8:	01812403          	lw	s0,24(sp)
80003cdc:	02010113          	addi	sp,sp,32
80003ce0:	00008067          	ret

80003ce4 <print_block>:

void print_block(void *block_ptr)
{
80003ce4:	fd010113          	addi	sp,sp,-48
80003ce8:	02112623          	sw	ra,44(sp)
80003cec:	02812423          	sw	s0,40(sp)
80003cf0:	03010413          	addi	s0,sp,48
80003cf4:	fca42e23          	sw	a0,-36(s0)
    mem_block *block_info = (mem_block *)(block_ptr - sizeof(mem_block));
80003cf8:	fdc42783          	lw	a5,-36(s0)
80003cfc:	ff478793          	addi	a5,a5,-12
80003d00:	fef42223          	sw	a5,-28(s0)
    void *block_end = block_ptr + block_info->size;
80003d04:	fe442783          	lw	a5,-28(s0)
80003d08:	0007a783          	lw	a5,0(a5)
80003d0c:	fdc42703          	lw	a4,-36(s0)
80003d10:	00f707b3          	add	a5,a4,a5
80003d14:	fef42023          	sw	a5,-32(s0)
    int byte_count = 1;
80003d18:	00100793          	li	a5,1
80003d1c:	fef42623          	sw	a5,-20(s0)
    int *int_block_ptr = (int *)block_ptr;
80003d20:	fdc42783          	lw	a5,-36(s0)
80003d24:	fef42423          	sw	a5,-24(s0)
    for (; int_block_ptr < block_end; int_block_ptr++, byte_count++)
80003d28:	0640006f          	j	80003d8c <print_block+0xa8>
    {
        printf("%d", (*int_block_ptr));
80003d2c:	fe842783          	lw	a5,-24(s0)
80003d30:	0007a783          	lw	a5,0(a5)
80003d34:	00078593          	mv	a1,a5
80003d38:	800067b7          	lui	a5,0x80006
80003d3c:	a4878513          	addi	a0,a5,-1464 # 80005a48 <_memory_end+0xf8005a48>
80003d40:	148010ef          	jal	ra,80004e88 <printf>
        if (byte_count % 4 == 0)
80003d44:	fec42783          	lw	a5,-20(s0)
80003d48:	0037f793          	andi	a5,a5,3
80003d4c:	00079863          	bnez	a5,80003d5c <print_block+0x78>
            printf(" ");
80003d50:	800067b7          	lui	a5,0x80006
80003d54:	a4c78513          	addi	a0,a5,-1460 # 80005a4c <_memory_end+0xf8005a4c>
80003d58:	130010ef          	jal	ra,80004e88 <printf>
        if (byte_count % 32 == 0)
80003d5c:	fec42783          	lw	a5,-20(s0)
80003d60:	01f7f793          	andi	a5,a5,31
80003d64:	00079863          	bnez	a5,80003d74 <print_block+0x90>
            printf("\n");
80003d68:	800067b7          	lui	a5,0x80006
80003d6c:	a5078513          	addi	a0,a5,-1456 # 80005a50 <_memory_end+0xf8005a50>
80003d70:	118010ef          	jal	ra,80004e88 <printf>
    for (; int_block_ptr < block_end; int_block_ptr++, byte_count++)
80003d74:	fe842783          	lw	a5,-24(s0)
80003d78:	00478793          	addi	a5,a5,4
80003d7c:	fef42423          	sw	a5,-24(s0)
80003d80:	fec42783          	lw	a5,-20(s0)
80003d84:	00178793          	addi	a5,a5,1
80003d88:	fef42623          	sw	a5,-20(s0)
80003d8c:	fe842703          	lw	a4,-24(s0)
80003d90:	fe042783          	lw	a5,-32(s0)
80003d94:	f8f76ce3          	bltu	a4,a5,80003d2c <print_block+0x48>
    }
    printf("\n\n");
80003d98:	800067b7          	lui	a5,0x80006
80003d9c:	a5478513          	addi	a0,a5,-1452 # 80005a54 <_memory_end+0xf8005a54>
80003da0:	0e8010ef          	jal	ra,80004e88 <printf>
80003da4:	00000013          	nop
80003da8:	02c12083          	lw	ra,44(sp)
80003dac:	02812403          	lw	s0,40(sp)
80003db0:	03010113          	addi	sp,sp,48
80003db4:	00008067          	ret

80003db8 <handle_syscall>:
    [SYS_uart_putc] = {(void *)uart_putc, 1} // 新增系统调用
};

// 处理系统调用
int handle_syscall(reg_t epc, reg_t cause)
{
80003db8:	fc010113          	addi	sp,sp,-64
80003dbc:	02112e23          	sw	ra,60(sp)
80003dc0:	02812c23          	sw	s0,56(sp)
80003dc4:	04010413          	addi	s0,sp,64
80003dc8:	fca42623          	sw	a0,-52(s0)
80003dcc:	fcb42423          	sw	a1,-56(s0)
    // 确认当前有正在运行的任务
    if (_current < 0) {
80003dd0:	800067b7          	lui	a5,0x80006
80003dd4:	0007a783          	lw	a5,0(a5) # 80006000 <_memory_end+0xf8006000>
80003dd8:	0007dc63          	bgez	a5,80003df0 <handle_syscall+0x38>
        printf("无活动任务执行系统调用\n");
80003ddc:	800067b7          	lui	a5,0x80006
80003de0:	a5878513          	addi	a0,a5,-1448 # 80005a58 <_memory_end+0xf8005a58>
80003de4:	0a4010ef          	jal	ra,80004e88 <printf>
        return -1;
80003de8:	fff00793          	li	a5,-1
80003dec:	2380006f          	j	80004024 <handle_syscall+0x26c>
    }
    
    // 从已保存的上下文中获取真正的系统调用参数
    reg_t syscall_num = tasks[_current].ctx.a7;  // 系统调用号
80003df0:	800067b7          	lui	a5,0x80006
80003df4:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
80003df8:	80b067b7          	lui	a5,0x80b06
80003dfc:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80003e00:	09c00793          	li	a5,156
80003e04:	02f687b3          	mul	a5,a3,a5
80003e08:	00f707b3          	add	a5,a4,a5
80003e0c:	0407a783          	lw	a5,64(a5)
80003e10:	fef42623          	sw	a5,-20(s0)
    reg_t a0 = tasks[_current].ctx.a0;
80003e14:	800067b7          	lui	a5,0x80006
80003e18:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
80003e1c:	80b067b7          	lui	a5,0x80b06
80003e20:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80003e24:	09c00793          	li	a5,156
80003e28:	02f687b3          	mul	a5,a3,a5
80003e2c:	00f707b3          	add	a5,a4,a5
80003e30:	0247a783          	lw	a5,36(a5)
80003e34:	fef42423          	sw	a5,-24(s0)
    reg_t a1 = tasks[_current].ctx.a1;
80003e38:	800067b7          	lui	a5,0x80006
80003e3c:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
80003e40:	80b067b7          	lui	a5,0x80b06
80003e44:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80003e48:	09c00793          	li	a5,156
80003e4c:	02f687b3          	mul	a5,a3,a5
80003e50:	00f707b3          	add	a5,a4,a5
80003e54:	0287a783          	lw	a5,40(a5)
80003e58:	fef42223          	sw	a5,-28(s0)
    reg_t a2 = tasks[_current].ctx.a2;
80003e5c:	800067b7          	lui	a5,0x80006
80003e60:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
80003e64:	80b067b7          	lui	a5,0x80b06
80003e68:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80003e6c:	09c00793          	li	a5,156
80003e70:	02f687b3          	mul	a5,a3,a5
80003e74:	00f707b3          	add	a5,a4,a5
80003e78:	02c7a783          	lw	a5,44(a5)
80003e7c:	fef42023          	sw	a5,-32(s0)
    reg_t a3 = tasks[_current].ctx.a3;
80003e80:	800067b7          	lui	a5,0x80006
80003e84:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
80003e88:	80b067b7          	lui	a5,0x80b06
80003e8c:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80003e90:	09c00793          	li	a5,156
80003e94:	02f687b3          	mul	a5,a3,a5
80003e98:	00f707b3          	add	a5,a4,a5
80003e9c:	0307a783          	lw	a5,48(a5)
80003ea0:	fcf42e23          	sw	a5,-36(s0)
    reg_t a4 = tasks[_current].ctx.a4;
80003ea4:	800067b7          	lui	a5,0x80006
80003ea8:	0007a683          	lw	a3,0(a5) # 80006000 <_memory_end+0xf8006000>
80003eac:	80b067b7          	lui	a5,0x80b06
80003eb0:	07078713          	addi	a4,a5,112 # 80b06070 <_memory_end+0xf8b06070>
80003eb4:	09c00793          	li	a5,156
80003eb8:	02f687b3          	mul	a5,a3,a5
80003ebc:	00f707b3          	add	a5,a4,a5
80003ec0:	0347a783          	lw	a5,52(a5)
80003ec4:	fcf42c23          	sw	a5,-40(s0)
    
    // 调试输出
    printf("系统调用: num=%d, a0=%p\n", syscall_num, (void*)a0);
80003ec8:	fe842783          	lw	a5,-24(s0)
80003ecc:	00078613          	mv	a2,a5
80003ed0:	fec42583          	lw	a1,-20(s0)
80003ed4:	800067b7          	lui	a5,0x80006
80003ed8:	a7c78513          	addi	a0,a5,-1412 # 80005a7c <_memory_end+0xf8005a7c>
80003edc:	7ad000ef          	jal	ra,80004e88 <printf>
    
    if (syscall_num > 0 && syscall_num < sizeof(syscalls)/sizeof(syscalls[0]) && syscalls[syscall_num].func)
80003ee0:	fec42783          	lw	a5,-20(s0)
80003ee4:	12078663          	beqz	a5,80004010 <handle_syscall+0x258>
80003ee8:	fec42703          	lw	a4,-20(s0)
80003eec:	00900793          	li	a5,9
80003ef0:	12e7e063          	bltu	a5,a4,80004010 <handle_syscall+0x258>
80003ef4:	800067b7          	lui	a5,0x80006
80003ef8:	00878713          	addi	a4,a5,8 # 80006008 <_memory_end+0xf8006008>
80003efc:	fec42783          	lw	a5,-20(s0)
80003f00:	00379793          	slli	a5,a5,0x3
80003f04:	00f707b3          	add	a5,a4,a5
80003f08:	0007a783          	lw	a5,0(a5)
80003f0c:	10078263          	beqz	a5,80004010 <handle_syscall+0x258>
    {
        void *func = syscalls[syscall_num].func;
80003f10:	800067b7          	lui	a5,0x80006
80003f14:	00878713          	addi	a4,a5,8 # 80006008 <_memory_end+0xf8006008>
80003f18:	fec42783          	lw	a5,-20(s0)
80003f1c:	00379793          	slli	a5,a5,0x3
80003f20:	00f707b3          	add	a5,a4,a5
80003f24:	0007a783          	lw	a5,0(a5)
80003f28:	fcf42a23          	sw	a5,-44(s0)
        int param_count = syscalls[syscall_num].param_count;
80003f2c:	800067b7          	lui	a5,0x80006
80003f30:	00878713          	addi	a4,a5,8 # 80006008 <_memory_end+0xf8006008>
80003f34:	fec42783          	lw	a5,-20(s0)
80003f38:	00379793          	slli	a5,a5,0x3
80003f3c:	00f707b3          	add	a5,a4,a5
80003f40:	0047a783          	lw	a5,4(a5)
80003f44:	fcf42823          	sw	a5,-48(s0)
80003f48:	fd042703          	lw	a4,-48(s0)
80003f4c:	00400793          	li	a5,4
80003f50:	0ae7ec63          	bltu	a5,a4,80004008 <handle_syscall+0x250>
80003f54:	fd042783          	lw	a5,-48(s0)
80003f58:	00279713          	slli	a4,a5,0x2
80003f5c:	800067b7          	lui	a5,0x80006
80003f60:	ab878793          	addi	a5,a5,-1352 # 80005ab8 <_memory_end+0xf8005ab8>
80003f64:	00f707b3          	add	a5,a4,a5
80003f68:	0007a783          	lw	a5,0(a5)
80003f6c:	00078067          	jr	a5
        
        // 原有的函数调用逻辑不变
        switch (param_count)
        {
        case 0:
            ((void (*)())func)();
80003f70:	fd442783          	lw	a5,-44(s0)
80003f74:	000780e7          	jalr	a5
            return 0;
80003f78:	00000793          	li	a5,0
80003f7c:	0a80006f          	j	80004024 <handle_syscall+0x26c>
        case 1:
            return (long)((void *(*)(long))func)(a0);
80003f80:	fd442703          	lw	a4,-44(s0)
80003f84:	fe842783          	lw	a5,-24(s0)
80003f88:	00078513          	mv	a0,a5
80003f8c:	000700e7          	jalr	a4
80003f90:	00050793          	mv	a5,a0
80003f94:	0900006f          	j	80004024 <handle_syscall+0x26c>
        case 2:
            return ((int (*)(long, long))func)(a0, a1);
80003f98:	fd442683          	lw	a3,-44(s0)
80003f9c:	fe842783          	lw	a5,-24(s0)
80003fa0:	fe442703          	lw	a4,-28(s0)
80003fa4:	00070593          	mv	a1,a4
80003fa8:	00078513          	mv	a0,a5
80003fac:	000680e7          	jalr	a3
80003fb0:	00050793          	mv	a5,a0
80003fb4:	0700006f          	j	80004024 <handle_syscall+0x26c>
        case 3:
            return ((int (*)(long, long, long))func)(a0, a1, a2);
80003fb8:	fd442803          	lw	a6,-44(s0)
80003fbc:	fe842783          	lw	a5,-24(s0)
80003fc0:	fe442703          	lw	a4,-28(s0)
80003fc4:	fe042683          	lw	a3,-32(s0)
80003fc8:	00068613          	mv	a2,a3
80003fcc:	00070593          	mv	a1,a4
80003fd0:	00078513          	mv	a0,a5
80003fd4:	000800e7          	jalr	a6
80003fd8:	00050793          	mv	a5,a0
80003fdc:	0480006f          	j	80004024 <handle_syscall+0x26c>
        case 4:
            return ((int (*)(long, long, long, long))func)(a0, a1, a2, a3);
80003fe0:	fd442803          	lw	a6,-44(s0)
80003fe4:	fe842783          	lw	a5,-24(s0)
80003fe8:	fe442703          	lw	a4,-28(s0)
80003fec:	fe042603          	lw	a2,-32(s0)
80003ff0:	fdc42683          	lw	a3,-36(s0)
80003ff4:	00070593          	mv	a1,a4
80003ff8:	00078513          	mv	a0,a5
80003ffc:	000800e7          	jalr	a6
80004000:	00050793          	mv	a5,a0
80004004:	0200006f          	j	80004024 <handle_syscall+0x26c>
        default:
            return -1;
80004008:	fff00793          	li	a5,-1
8000400c:	0180006f          	j	80004024 <handle_syscall+0x26c>
        }
    }

    printf("未知的系统调用: %d\n", syscall_num);
80004010:	fec42583          	lw	a1,-20(s0)
80004014:	800067b7          	lui	a5,0x80006
80004018:	a9c78513          	addi	a0,a5,-1380 # 80005a9c <_memory_end+0xf8005a9c>
8000401c:	66d000ef          	jal	ra,80004e88 <printf>
    return -1;
80004020:	fff00793          	li	a5,-1
80004024:	00078513          	mv	a0,a5
80004028:	03c12083          	lw	ra,60(sp)
8000402c:	03812403          	lw	s0,56(sp)
80004030:	04010113          	addi	sp,sp,64
80004034:	00008067          	ret

80004038 <uart_init>:

#define uart_read_reg(reg) (*(UART_REG(reg)))
#define uart_write_reg(reg, v) (*(UART_REG(reg)) = (v))

void uart_init()
{
80004038:	fe010113          	addi	sp,sp,-32
8000403c:	00812e23          	sw	s0,28(sp)
80004040:	02010413          	addi	s0,sp,32
	/* disable interrupts. */
	uart_write_reg(IER, 0x00);
80004044:	100007b7          	lui	a5,0x10000
80004048:	00178793          	addi	a5,a5,1 # 10000001 <_heap_size+0x8c06b09>
8000404c:	00078023          	sb	zero,0(a5)
	 * We use 38.4K when 1.8432 MHZ crystal, so the corresponding value is 3.
	 * And due to the divisor register is two bytes (16 bits), so we need to
	 * split the value of 3(0x0003) into two bytes, DLL stores the low byte,
	 * DLM stores the high byte.
	 */
	uint8_t lcr = uart_read_reg(LCR);
80004050:	100007b7          	lui	a5,0x10000
80004054:	00378793          	addi	a5,a5,3 # 10000003 <_heap_size+0x8c06b0b>
80004058:	0007c783          	lbu	a5,0(a5)
8000405c:	fef407a3          	sb	a5,-17(s0)
	uart_write_reg(LCR, lcr | (1 << 7));
80004060:	100007b7          	lui	a5,0x10000
80004064:	00378793          	addi	a5,a5,3 # 10000003 <_heap_size+0x8c06b0b>
80004068:	fef44703          	lbu	a4,-17(s0)
8000406c:	f8076713          	ori	a4,a4,-128
80004070:	0ff77713          	andi	a4,a4,255
80004074:	00e78023          	sb	a4,0(a5)
	uart_write_reg(DLL, 0x03);
80004078:	100007b7          	lui	a5,0x10000
8000407c:	00300713          	li	a4,3
80004080:	00e78023          	sb	a4,0(a5) # 10000000 <_heap_size+0x8c06b08>
	uart_write_reg(DLM, 0x00);
80004084:	100007b7          	lui	a5,0x10000
80004088:	00178793          	addi	a5,a5,1 # 10000001 <_heap_size+0x8c06b09>
8000408c:	00078023          	sb	zero,0(a5)
	 * - number of stop bits：1 bit when word length is 8 bits
	 * - no parity
	 * - no break control
	 * - disabled baud latch
	 */
	lcr = 0;
80004090:	fe0407a3          	sb	zero,-17(s0)
	uart_write_reg(LCR, lcr | (3 << 0));
80004094:	100007b7          	lui	a5,0x10000
80004098:	00378793          	addi	a5,a5,3 # 10000003 <_heap_size+0x8c06b0b>
8000409c:	fef44703          	lbu	a4,-17(s0)
800040a0:	00376713          	ori	a4,a4,3
800040a4:	0ff77713          	andi	a4,a4,255
800040a8:	00e78023          	sb	a4,0(a5)
}
800040ac:	00000013          	nop
800040b0:	01c12403          	lw	s0,28(sp)
800040b4:	02010113          	addi	sp,sp,32
800040b8:	00008067          	ret

800040bc <uart_putc>:

int uart_putc(char ch)
{
800040bc:	fe010113          	addi	sp,sp,-32
800040c0:	00812e23          	sw	s0,28(sp)
800040c4:	02010413          	addi	s0,sp,32
800040c8:	00050793          	mv	a5,a0
800040cc:	fef407a3          	sb	a5,-17(s0)
	while ((uart_read_reg(LSR) & LSR_TX_IDLE) == 0);
800040d0:	00000013          	nop
800040d4:	100007b7          	lui	a5,0x10000
800040d8:	00578793          	addi	a5,a5,5 # 10000005 <_heap_size+0x8c06b0d>
800040dc:	0007c783          	lbu	a5,0(a5)
800040e0:	0ff7f793          	andi	a5,a5,255
800040e4:	0207f793          	andi	a5,a5,32
800040e8:	fe0786e3          	beqz	a5,800040d4 <uart_putc+0x18>
	return uart_write_reg(THR, ch);
800040ec:	10000737          	lui	a4,0x10000
800040f0:	fef44783          	lbu	a5,-17(s0)
800040f4:	00f70023          	sb	a5,0(a4) # 10000000 <_heap_size+0x8c06b08>
}
800040f8:	00078513          	mv	a0,a5
800040fc:	01c12403          	lw	s0,28(sp)
80004100:	02010113          	addi	sp,sp,32
80004104:	00008067          	ret

80004108 <uart_puts>:

void uart_puts(char *s)
{
80004108:	fe010113          	addi	sp,sp,-32
8000410c:	00112e23          	sw	ra,28(sp)
80004110:	00812c23          	sw	s0,24(sp)
80004114:	02010413          	addi	s0,sp,32
80004118:	fea42623          	sw	a0,-20(s0)
	while (*s) {
8000411c:	01c0006f          	j	80004138 <uart_puts+0x30>
		uart_putc(*s++);
80004120:	fec42783          	lw	a5,-20(s0)
80004124:	00178713          	addi	a4,a5,1
80004128:	fee42623          	sw	a4,-20(s0)
8000412c:	0007c783          	lbu	a5,0(a5)
80004130:	00078513          	mv	a0,a5
80004134:	f89ff0ef          	jal	ra,800040bc <uart_putc>
	while (*s) {
80004138:	fec42783          	lw	a5,-20(s0)
8000413c:	0007c783          	lbu	a5,0(a5)
80004140:	fe0790e3          	bnez	a5,80004120 <uart_puts+0x18>
	}
}
80004144:	00000013          	nop
80004148:	00000013          	nop
8000414c:	01c12083          	lw	ra,28(sp)
80004150:	01812403          	lw	s0,24(sp)
80004154:	02010113          	addi	sp,sp,32
80004158:	00008067          	ret

8000415c <uart_getc>:

int uart_getc(void)
{
8000415c:	ff010113          	addi	sp,sp,-16
80004160:	00812623          	sw	s0,12(sp)
80004164:	01010413          	addi	s0,sp,16
	if (uart_read_reg(LSR) & LSR_RX_READY){
80004168:	100007b7          	lui	a5,0x10000
8000416c:	00578793          	addi	a5,a5,5 # 10000005 <_heap_size+0x8c06b0d>
80004170:	0007c783          	lbu	a5,0(a5)
80004174:	0ff7f793          	andi	a5,a5,255
80004178:	0017f793          	andi	a5,a5,1
8000417c:	00078a63          	beqz	a5,80004190 <uart_getc+0x34>
		return uart_read_reg(RHR);
80004180:	100007b7          	lui	a5,0x10000
80004184:	0007c783          	lbu	a5,0(a5) # 10000000 <_heap_size+0x8c06b08>
80004188:	0ff7f793          	andi	a5,a5,255
8000418c:	0080006f          	j	80004194 <uart_getc+0x38>
	} else {
		return -1;
80004190:	fff00793          	li	a5,-1
	}
}
80004194:	00078513          	mv	a0,a5
80004198:	00c12403          	lw	s0,12(sp)
8000419c:	01010113          	addi	sp,sp,16
800041a0:	00008067          	ret

800041a4 <uart_isr>:

void uart_isr(void)
{
800041a4:	fe010113          	addi	sp,sp,-32
800041a8:	00112e23          	sw	ra,28(sp)
800041ac:	00812c23          	sw	s0,24(sp)
800041b0:	02010413          	addi	s0,sp,32
	while (1) {
		int c = uart_getc();
800041b4:	fa9ff0ef          	jal	ra,8000415c <uart_getc>
800041b8:	fea42623          	sw	a0,-20(s0)
		if (c == -1) {
800041bc:	fec42703          	lw	a4,-20(s0)
800041c0:	fff00793          	li	a5,-1
800041c4:	02f70063          	beq	a4,a5,800041e4 <uart_isr+0x40>
			break;
		} else {
			uart_putc((char)c);
800041c8:	fec42783          	lw	a5,-20(s0)
800041cc:	0ff7f793          	andi	a5,a5,255
800041d0:	00078513          	mv	a0,a5
800041d4:	ee9ff0ef          	jal	ra,800040bc <uart_putc>
			uart_putc('\n');
800041d8:	00a00513          	li	a0,10
800041dc:	ee1ff0ef          	jal	ra,800040bc <uart_putc>
	while (1) {
800041e0:	fd5ff06f          	j	800041b4 <uart_isr+0x10>
			break;
800041e4:	00000013          	nop
		}
	}
}
800041e8:	00000013          	nop
800041ec:	01c12083          	lw	ra,28(sp)
800041f0:	01812403          	lw	s0,24(sp)
800041f4:	02010113          	addi	sp,sp,32
800041f8:	00008067          	ret

800041fc <r_tp>:
{
800041fc:	fe010113          	addi	sp,sp,-32
80004200:	00812e23          	sw	s0,28(sp)
80004204:	02010413          	addi	s0,sp,32
	asm volatile("mv %0, tp" : "=r" (x) );
80004208:	00020793          	mv	a5,tp
8000420c:	fef42623          	sw	a5,-20(s0)
	return x;
80004210:	fec42783          	lw	a5,-20(s0)
}
80004214:	00078513          	mv	a0,a5
80004218:	01c12403          	lw	s0,28(sp)
8000421c:	02010113          	addi	sp,sp,32
80004220:	00008067          	ret

80004224 <r_mstatus>:
{
80004224:	fe010113          	addi	sp,sp,-32
80004228:	00812e23          	sw	s0,28(sp)
8000422c:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mstatus" : "=r" (x) );
80004230:	300027f3          	csrr	a5,mstatus
80004234:	fef42623          	sw	a5,-20(s0)
	return x;
80004238:	fec42783          	lw	a5,-20(s0)
}
8000423c:	00078513          	mv	a0,a5
80004240:	01c12403          	lw	s0,28(sp)
80004244:	02010113          	addi	sp,sp,32
80004248:	00008067          	ret

8000424c <w_mstatus>:
{
8000424c:	fe010113          	addi	sp,sp,-32
80004250:	00812e23          	sw	s0,28(sp)
80004254:	02010413          	addi	s0,sp,32
80004258:	fea42623          	sw	a0,-20(s0)
	asm volatile("csrw mstatus, %0" : : "r" (x));
8000425c:	fec42783          	lw	a5,-20(s0)
80004260:	30079073          	csrw	mstatus,a5
}
80004264:	00000013          	nop
80004268:	01c12403          	lw	s0,28(sp)
8000426c:	02010113          	addi	sp,sp,32
80004270:	00008067          	ret

80004274 <r_mie>:
{
80004274:	fe010113          	addi	sp,sp,-32
80004278:	00812e23          	sw	s0,28(sp)
8000427c:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mie" : "=r" (x) );
80004280:	304027f3          	csrr	a5,mie
80004284:	fef42623          	sw	a5,-20(s0)
	return x;
80004288:	fec42783          	lw	a5,-20(s0)
}
8000428c:	00078513          	mv	a0,a5
80004290:	01c12403          	lw	s0,28(sp)
80004294:	02010113          	addi	sp,sp,32
80004298:	00008067          	ret

8000429c <w_mie>:
{
8000429c:	fe010113          	addi	sp,sp,-32
800042a0:	00812e23          	sw	s0,28(sp)
800042a4:	02010413          	addi	s0,sp,32
800042a8:	fea42623          	sw	a0,-20(s0)
	asm volatile("csrw mie, %0" : : "r" (x));
800042ac:	fec42783          	lw	a5,-20(s0)
800042b0:	30479073          	csrw	mie,a5
}
800042b4:	00000013          	nop
800042b8:	01c12403          	lw	s0,28(sp)
800042bc:	02010113          	addi	sp,sp,32
800042c0:	00008067          	ret

800042c4 <plic_init>:
#include "os.h"

void plic_init(void)
{
800042c4:	fe010113          	addi	sp,sp,-32
800042c8:	00112e23          	sw	ra,28(sp)
800042cc:	00812c23          	sw	s0,24(sp)
800042d0:	02010413          	addi	s0,sp,32
	int hart = r_tp();
800042d4:	f29ff0ef          	jal	ra,800041fc <r_tp>
800042d8:	00050793          	mv	a5,a0
800042dc:	fef42623          	sw	a5,-20(s0)
	 * Priority 1 is the lowest active priority, and priority 7 is the highest. 
	 * Ties between global interrupts of the same priority are broken by 
	 * the Interrupt ID; interrupts with the lowest ID have the highest 
	 * effective priority.
	 */
	*(uint32_t*)PLIC_PRIORITY(UART0_IRQ) = 1;
800042e0:	0c0007b7          	lui	a5,0xc000
800042e4:	02878793          	addi	a5,a5,40 # c000028 <_heap_size+0x4c06b30>
800042e8:	00100713          	li	a4,1
800042ec:	00e7a023          	sw	a4,0(a5)
	 * Enable UART0
	 *
	 * Each global interrupt can be enabled by setting the corresponding 
	 * bit in the enables registers.
	 */
	*(uint32_t*)PLIC_MENABLE(hart)= (1 << UART0_IRQ);
800042f0:	fec42703          	lw	a4,-20(s0)
800042f4:	001807b7          	lui	a5,0x180
800042f8:	04078793          	addi	a5,a5,64 # 180040 <STACK_SIZE+0x17fc40>
800042fc:	00f707b3          	add	a5,a4,a5
80004300:	00779793          	slli	a5,a5,0x7
80004304:	00078713          	mv	a4,a5
80004308:	40000793          	li	a5,1024
8000430c:	00f72023          	sw	a5,0(a4)
	 * Maximum threshold is 7.
	 * For example, a threshold value of zero permits all interrupts with
	 * non-zero priority, whereas a value of 7 masks all interrupts.
	 * Notice, the threshold is global for PLIC, not for each interrupt source.
	 */
	*(uint32_t*)PLIC_MTHRESHOLD(hart) = 0;
80004310:	fec42703          	lw	a4,-20(s0)
80004314:	0000c7b7          	lui	a5,0xc
80004318:	20078793          	addi	a5,a5,512 # c200 <STACK_SIZE+0xbe00>
8000431c:	00f707b3          	add	a5,a4,a5
80004320:	00c79793          	slli	a5,a5,0xc
80004324:	0007a023          	sw	zero,0(a5)

	/* enable machine-mode external interrupts. */
	w_mie(r_mie() | MIE_MEIE);
80004328:	f4dff0ef          	jal	ra,80004274 <r_mie>
8000432c:	00050713          	mv	a4,a0
80004330:	000017b7          	lui	a5,0x1
80004334:	80078793          	addi	a5,a5,-2048 # 800 <STACK_SIZE+0x400>
80004338:	00f767b3          	or	a5,a4,a5
8000433c:	00078513          	mv	a0,a5
80004340:	f5dff0ef          	jal	ra,8000429c <w_mie>


	/* enable machine-mode global interrupts. */
	w_mstatus(r_mstatus() | MSTATUS_MIE);
80004344:	ee1ff0ef          	jal	ra,80004224 <r_mstatus>
80004348:	00050793          	mv	a5,a0
8000434c:	0087e793          	ori	a5,a5,8
80004350:	00078513          	mv	a0,a5
80004354:	ef9ff0ef          	jal	ra,8000424c <w_mstatus>
}
80004358:	00000013          	nop
8000435c:	01c12083          	lw	ra,28(sp)
80004360:	01812403          	lw	s0,24(sp)
80004364:	02010113          	addi	sp,sp,32
80004368:	00008067          	ret

8000436c <plic_claim>:
 * RETURN VALUE:
 *	the ID of the highest-priority pending interrupt or zero if there 
 *	is no pending interrupt.
 */
int plic_claim(void)
{
8000436c:	fe010113          	addi	sp,sp,-32
80004370:	00112e23          	sw	ra,28(sp)
80004374:	00812c23          	sw	s0,24(sp)
80004378:	02010413          	addi	s0,sp,32
	int hart = r_tp();
8000437c:	e81ff0ef          	jal	ra,800041fc <r_tp>
80004380:	00050793          	mv	a5,a0
80004384:	fef42623          	sw	a5,-20(s0)
	int irq = *(uint32_t*)PLIC_MCLAIM(hart);
80004388:	fec42783          	lw	a5,-20(s0)
8000438c:	00c79713          	slli	a4,a5,0xc
80004390:	0c2007b7          	lui	a5,0xc200
80004394:	00478793          	addi	a5,a5,4 # c200004 <_heap_size+0x4e06b0c>
80004398:	00f707b3          	add	a5,a4,a5
8000439c:	0007a783          	lw	a5,0(a5)
800043a0:	fef42423          	sw	a5,-24(s0)
	return irq;
800043a4:	fe842783          	lw	a5,-24(s0)
}
800043a8:	00078513          	mv	a0,a5
800043ac:	01c12083          	lw	ra,28(sp)
800043b0:	01812403          	lw	s0,24(sp)
800043b4:	02010113          	addi	sp,sp,32
800043b8:	00008067          	ret

800043bc <plic_complete>:
 *	interrupt source that is currently enabled for the target, the completion
 *	is silently ignored.
 * RETURN VALUE: none
 */
void plic_complete(int irq)
{
800043bc:	fd010113          	addi	sp,sp,-48
800043c0:	02112623          	sw	ra,44(sp)
800043c4:	02812423          	sw	s0,40(sp)
800043c8:	03010413          	addi	s0,sp,48
800043cc:	fca42e23          	sw	a0,-36(s0)
	int hart = r_tp();
800043d0:	e2dff0ef          	jal	ra,800041fc <r_tp>
800043d4:	00050793          	mv	a5,a0
800043d8:	fef42623          	sw	a5,-20(s0)
	*(uint32_t*)PLIC_MCOMPLETE(hart) = irq;
800043dc:	fec42783          	lw	a5,-20(s0)
800043e0:	00c79713          	slli	a4,a5,0xc
800043e4:	0c2007b7          	lui	a5,0xc200
800043e8:	00478793          	addi	a5,a5,4 # c200004 <_heap_size+0x4e06b0c>
800043ec:	00f707b3          	add	a5,a4,a5
800043f0:	00078713          	mv	a4,a5
800043f4:	fdc42783          	lw	a5,-36(s0)
800043f8:	00f72023          	sw	a5,0(a4)
}
800043fc:	00000013          	nop
80004400:	02c12083          	lw	ra,44(sp)
80004404:	02812403          	lw	s0,40(sp)
80004408:	03010113          	addi	sp,sp,48
8000440c:	00008067          	ret

80004410 <r_mhartid>:
{
80004410:	fe010113          	addi	sp,sp,-32
80004414:	00812e23          	sw	s0,28(sp)
80004418:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mhartid" : "=r" (x) );
8000441c:	f14027f3          	csrr	a5,mhartid
80004420:	fef42623          	sw	a5,-20(s0)
	return x;
80004424:	fec42783          	lw	a5,-20(s0)
}
80004428:	00078513          	mv	a0,a5
8000442c:	01c12403          	lw	s0,28(sp)
80004430:	02010113          	addi	sp,sp,32
80004434:	00008067          	ret

80004438 <r_mie>:
{
80004438:	fe010113          	addi	sp,sp,-32
8000443c:	00812e23          	sw	s0,28(sp)
80004440:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mie" : "=r" (x) );
80004444:	304027f3          	csrr	a5,mie
80004448:	fef42623          	sw	a5,-20(s0)
	return x;
8000444c:	fec42783          	lw	a5,-20(s0)
}
80004450:	00078513          	mv	a0,a5
80004454:	01c12403          	lw	s0,28(sp)
80004458:	02010113          	addi	sp,sp,32
8000445c:	00008067          	ret

80004460 <w_mie>:
{
80004460:	fe010113          	addi	sp,sp,-32
80004464:	00812e23          	sw	s0,28(sp)
80004468:	02010413          	addi	s0,sp,32
8000446c:	fea42623          	sw	a0,-20(s0)
	asm volatile("csrw mie, %0" : : "r" (x));
80004470:	fec42783          	lw	a5,-20(s0)
80004474:	30479073          	csrw	mie,a5
}
80004478:	00000013          	nop
8000447c:	01c12403          	lw	s0,28(sp)
80004480:	02010113          	addi	sp,sp,32
80004484:	00008067          	ret

80004488 <timer_load>:

static uint32_t _tick = 0;

/* load timer interval(in ticks) for next timer interrupt.*/
void timer_load(int timeout_tick)
{
80004488:	fd010113          	addi	sp,sp,-48
8000448c:	02112623          	sw	ra,44(sp)
80004490:	02812423          	sw	s0,40(sp)
80004494:	03212223          	sw	s2,36(sp)
80004498:	03312023          	sw	s3,32(sp)
8000449c:	03010413          	addi	s0,sp,48
800044a0:	fca42e23          	sw	a0,-36(s0)
    /* each CPU has a separate source of timer interrupts. */
    int id = r_mhartid();
800044a4:	f6dff0ef          	jal	ra,80004410 <r_mhartid>
800044a8:	00050793          	mv	a5,a0
800044ac:	fef42623          	sw	a5,-20(s0)

    *(uint64_t *)CLINT_MTIMECMP(id) = timeout_tick;
800044b0:	fec42703          	lw	a4,-20(s0)
800044b4:	004017b7          	lui	a5,0x401
800044b8:	80078793          	addi	a5,a5,-2048 # 400800 <STACK_SIZE+0x400400>
800044bc:	00f707b3          	add	a5,a4,a5
800044c0:	00379793          	slli	a5,a5,0x3
800044c4:	00078713          	mv	a4,a5
800044c8:	fdc42783          	lw	a5,-36(s0)
800044cc:	00078913          	mv	s2,a5
800044d0:	41f7d793          	srai	a5,a5,0x1f
800044d4:	00078993          	mv	s3,a5
800044d8:	01272023          	sw	s2,0(a4)
800044dc:	01372223          	sw	s3,4(a4)
}
800044e0:	00000013          	nop
800044e4:	02c12083          	lw	ra,44(sp)
800044e8:	02812403          	lw	s0,40(sp)
800044ec:	02412903          	lw	s2,36(sp)
800044f0:	02012983          	lw	s3,32(sp)
800044f4:	03010113          	addi	sp,sp,48
800044f8:	00008067          	ret

800044fc <get_mtimecmp>:

uint32_t get_mtimecmp(void)
{
800044fc:	fe010113          	addi	sp,sp,-32
80004500:	00112e23          	sw	ra,28(sp)
80004504:	00812c23          	sw	s0,24(sp)
80004508:	02010413          	addi	s0,sp,32
    int id = r_mhartid();
8000450c:	f05ff0ef          	jal	ra,80004410 <r_mhartid>
80004510:	00050793          	mv	a5,a0
80004514:	fef42623          	sw	a5,-20(s0)
    volatile uint32_t *mtimecmp_ptr = (volatile uint32_t *)CLINT_MTIMECMP(id);
80004518:	fec42703          	lw	a4,-20(s0)
8000451c:	004017b7          	lui	a5,0x401
80004520:	80078793          	addi	a5,a5,-2048 # 400800 <STACK_SIZE+0x400400>
80004524:	00f707b3          	add	a5,a4,a5
80004528:	00379793          	slli	a5,a5,0x3
8000452c:	fef42423          	sw	a5,-24(s0)
    return *mtimecmp_ptr;
80004530:	fe842783          	lw	a5,-24(s0)
80004534:	0007a783          	lw	a5,0(a5)
}
80004538:	00078513          	mv	a0,a5
8000453c:	01c12083          	lw	ra,28(sp)
80004540:	01812403          	lw	s0,24(sp)
80004544:	02010113          	addi	sp,sp,32
80004548:	00008067          	ret

8000454c <timer_init>:

void timer_init()
{
8000454c:	ff010113          	addi	sp,sp,-16
80004550:	00112623          	sw	ra,12(sp)
80004554:	00812423          	sw	s0,8(sp)
80004558:	01010413          	addi	s0,sp,16
     * are not reset. So we have to init the mtimecmp manually.
     */
    // timer_create(timer_handler, NULL, 1);

    /* enable machine-mode timer interrupts. */
    w_mie(r_mie() | MIE_MTIE);
8000455c:	eddff0ef          	jal	ra,80004438 <r_mie>
80004560:	00050793          	mv	a5,a0
80004564:	0807e793          	ori	a5,a5,128
80004568:	00078513          	mv	a0,a5
8000456c:	ef5ff0ef          	jal	ra,80004460 <w_mie>
    /* enable machine-mode global interrupts. */
    // w_mstatus(r_mstatus() | MSTATUS_MIE);
}
80004570:	00000013          	nop
80004574:	00c12083          	lw	ra,12(sp)
80004578:	00812403          	lw	s0,8(sp)
8000457c:	01010113          	addi	sp,sp,16
80004580:	00008067          	ret

80004584 <get_mtime>:

uint32_t get_mtime(void)
{
80004584:	fe010113          	addi	sp,sp,-32
80004588:	00812e23          	sw	s0,28(sp)
8000458c:	02010413          	addi	s0,sp,32
    // 确保地址正确对齐
    volatile uint32_t *mtime_ptr = (volatile uint32_t *)(CLINT_BASE + 0xBFF8);
80004590:	0200c7b7          	lui	a5,0x200c
80004594:	ff878793          	addi	a5,a5,-8 # 200bff8 <STACK_SIZE+0x200bbf8>
80004598:	fef42623          	sw	a5,-20(s0)
    return *mtime_ptr;
8000459c:	fec42783          	lw	a5,-20(s0)
800045a0:	0007a783          	lw	a5,0(a5)
}
800045a4:	00078513          	mv	a0,a5
800045a8:	01c12403          	lw	s0,28(sp)
800045ac:	02010113          	addi	sp,sp,32
800045b0:	00008067          	ret

800045b4 <timer_create>:

timer *timer_create(void (*handler)(void *arg), void *arg, uint32_t timeout)
{
800045b4:	fd010113          	addi	sp,sp,-48
800045b8:	02112623          	sw	ra,44(sp)
800045bc:	02812423          	sw	s0,40(sp)
800045c0:	03010413          	addi	s0,sp,48
800045c4:	fca42e23          	sw	a0,-36(s0)
800045c8:	fcb42c23          	sw	a1,-40(s0)
800045cc:	fcc42a23          	sw	a2,-44(s0)
    timer *t = malloc(sizeof(timer));
800045d0:	01000513          	li	a0,16
800045d4:	bc0ff0ef          	jal	ra,80003994 <malloc>
800045d8:	fea42623          	sw	a0,-20(s0)
    if (t == NULL)
800045dc:	fec42783          	lw	a5,-20(s0)
800045e0:	00079663          	bnez	a5,800045ec <timer_create+0x38>
    {
        return NULL;
800045e4:	00000793          	li	a5,0
800045e8:	06c0006f          	j	80004654 <timer_create+0xa0>
    }
    t->func = handler;
800045ec:	fec42783          	lw	a5,-20(s0)
800045f0:	fdc42703          	lw	a4,-36(s0)
800045f4:	00e7a023          	sw	a4,0(a5)
    t->arg = arg;
800045f8:	fec42783          	lw	a5,-20(s0)
800045fc:	fd842703          	lw	a4,-40(s0)
80004600:	00e7a223          	sw	a4,4(a5)
    t->timeout_tick = get_mtime() + timeout * TIMER_INTERVAL;
80004604:	f81ff0ef          	jal	ra,80004584 <get_mtime>
80004608:	00050693          	mv	a3,a0
8000460c:	fd442703          	lw	a4,-44(s0)
80004610:	009897b7          	lui	a5,0x989
80004614:	68078793          	addi	a5,a5,1664 # 989680 <STACK_SIZE+0x989280>
80004618:	02f707b3          	mul	a5,a4,a5
8000461c:	00f68733          	add	a4,a3,a5
80004620:	fec42783          	lw	a5,-20(s0)
80004624:	00e7a423          	sw	a4,8(a5)
    t->next = NULL;
80004628:	fec42783          	lw	a5,-20(s0)
8000462c:	0007a623          	sw	zero,12(a5)
    timers = insert_to_timer_list(timers, t);
80004630:	800067b7          	lui	a5,0x80006
80004634:	0607a783          	lw	a5,96(a5) # 80006060 <_memory_end+0xf8006060>
80004638:	fec42583          	lw	a1,-20(s0)
8000463c:	00078513          	mv	a0,a5
80004640:	13d000ef          	jal	ra,80004f7c <insert_to_timer_list>
80004644:	00050713          	mv	a4,a0
80004648:	800067b7          	lui	a5,0x80006
8000464c:	06e7a023          	sw	a4,96(a5) # 80006060 <_memory_end+0xf8006060>
    // timer_load(timeout); // 确保加载定时器
    return t;
80004650:	fec42783          	lw	a5,-20(s0)
}
80004654:	00078513          	mv	a0,a5
80004658:	02c12083          	lw	ra,44(sp)
8000465c:	02812403          	lw	s0,40(sp)
80004660:	03010113          	addi	sp,sp,48
80004664:	00008067          	ret

80004668 <timer_delete>:

void timer_delete(timer *timer)
{
80004668:	fe010113          	addi	sp,sp,-32
8000466c:	00112e23          	sw	ra,28(sp)
80004670:	00812c23          	sw	s0,24(sp)
80004674:	02010413          	addi	s0,sp,32
80004678:	fea42623          	sw	a0,-20(s0)
    timers = delete_from_timer_list(timers, timer);
8000467c:	800067b7          	lui	a5,0x80006
80004680:	0607a783          	lw	a5,96(a5) # 80006060 <_memory_end+0xf8006060>
80004684:	fec42583          	lw	a1,-20(s0)
80004688:	00078513          	mv	a0,a5
8000468c:	285000ef          	jal	ra,80005110 <delete_from_timer_list>
80004690:	00050713          	mv	a4,a0
80004694:	800067b7          	lui	a5,0x80006
80004698:	06e7a023          	sw	a4,96(a5) # 80006060 <_memory_end+0xf8006060>
    free(timer);
8000469c:	fec42503          	lw	a0,-20(s0)
800046a0:	c7cff0ef          	jal	ra,80003b1c <free>
}
800046a4:	00000013          	nop
800046a8:	01c12083          	lw	ra,28(sp)
800046ac:	01812403          	lw	s0,24(sp)
800046b0:	02010113          	addi	sp,sp,32
800046b4:	00008067          	ret

800046b8 <run_timer_list>:

void run_timer_list()
{
800046b8:	fe010113          	addi	sp,sp,-32
800046bc:	00112e23          	sw	ra,28(sp)
800046c0:	00812c23          	sw	s0,24(sp)
800046c4:	00912a23          	sw	s1,20(sp)
800046c8:	02010413          	addi	s0,sp,32
    //printf("timer expired: %ld\n", timers->timeout_tick);
    //printf("current tick: %ld\n", get_mtime());
    while (timers != NULL && timers->timeout_tick <= get_mtime())
800046cc:	0440006f          	j	80004710 <run_timer_list+0x58>
    {
        timer *expired = timers;
800046d0:	800067b7          	lui	a5,0x80006
800046d4:	0607a783          	lw	a5,96(a5) # 80006060 <_memory_end+0xf8006060>
800046d8:	fef42623          	sw	a5,-20(s0)
        timers = timers->next;
800046dc:	800067b7          	lui	a5,0x80006
800046e0:	0607a783          	lw	a5,96(a5) # 80006060 <_memory_end+0xf8006060>
800046e4:	00c7a703          	lw	a4,12(a5)
800046e8:	800067b7          	lui	a5,0x80006
800046ec:	06e7a023          	sw	a4,96(a5) # 80006060 <_memory_end+0xf8006060>
        
        // 执行定时器回调
        expired->func(expired->arg);
800046f0:	fec42783          	lw	a5,-20(s0)
800046f4:	0007a703          	lw	a4,0(a5)
800046f8:	fec42783          	lw	a5,-20(s0)
800046fc:	0047a783          	lw	a5,4(a5)
80004700:	00078513          	mv	a0,a5
80004704:	000700e7          	jalr	a4
        
        // 释放定时器
        free(expired);
80004708:	fec42503          	lw	a0,-20(s0)
8000470c:	c10ff0ef          	jal	ra,80003b1c <free>
    while (timers != NULL && timers->timeout_tick <= get_mtime())
80004710:	800067b7          	lui	a5,0x80006
80004714:	0607a783          	lw	a5,96(a5) # 80006060 <_memory_end+0xf8006060>
80004718:	00078e63          	beqz	a5,80004734 <run_timer_list+0x7c>
8000471c:	800067b7          	lui	a5,0x80006
80004720:	0607a783          	lw	a5,96(a5) # 80006060 <_memory_end+0xf8006060>
80004724:	0087a483          	lw	s1,8(a5)
80004728:	e5dff0ef          	jal	ra,80004584 <get_mtime>
8000472c:	00050793          	mv	a5,a0
80004730:	fa97f0e3          	bgeu	a5,s1,800046d0 <run_timer_list+0x18>
    }
    if (timers == NULL)
80004734:	800067b7          	lui	a5,0x80006
80004738:	0607a783          	lw	a5,96(a5) # 80006060 <_memory_end+0xf8006060>
8000473c:	02079063          	bnez	a5,8000475c <run_timer_list+0xa4>
    {
        timer_create(task_yield, NULL, 1);
80004740:	00100613          	li	a2,1
80004744:	00000593          	li	a1,0
80004748:	800037b7          	lui	a5,0x80003
8000474c:	a2078513          	addi	a0,a5,-1504 # 80002a20 <_memory_end+0xf8002a20>
80004750:	e65ff0ef          	jal	ra,800045b4 <timer_create>
        spin_unlock();
80004754:	be5fe0ef          	jal	ra,80003338 <spin_unlock>
        return;
80004758:	0180006f          	j	80004770 <run_timer_list+0xb8>
    }
    timer_load(timers->timeout_tick);
8000475c:	800067b7          	lui	a5,0x80006
80004760:	0607a783          	lw	a5,96(a5) # 80006060 <_memory_end+0xf8006060>
80004764:	0087a783          	lw	a5,8(a5)
80004768:	00078513          	mv	a0,a5
8000476c:	d1dff0ef          	jal	ra,80004488 <timer_load>
}
80004770:	01c12083          	lw	ra,28(sp)
80004774:	01812403          	lw	s0,24(sp)
80004778:	01412483          	lw	s1,20(sp)
8000477c:	02010113          	addi	sp,sp,32
80004780:	00008067          	ret

80004784 <timer_handler>:

void timer_handler()
{
80004784:	ff010113          	addi	sp,sp,-16
80004788:	00112623          	sw	ra,12(sp)
8000478c:	00812423          	sw	s0,8(sp)
80004790:	01010413          	addi	s0,sp,16
    spin_lock();
80004794:	b69fe0ef          	jal	ra,800032fc <spin_lock>
    //print_timers();
    // if (timers->func == timer_handler)
    // {
    //     timer_create(timer_handler, NULL, 1);
    // }
    run_timer_list();
80004798:	f21ff0ef          	jal	ra,800046b8 <run_timer_list>
    spin_unlock();
8000479c:	b9dfe0ef          	jal	ra,80003338 <spin_unlock>
    //uart_puts("timer handler\n");
    // check_timeslice();
}
800047a0:	00000013          	nop
800047a4:	00c12083          	lw	ra,12(sp)
800047a8:	00812403          	lw	s0,8(sp)
800047ac:	01010113          	addi	sp,sp,16
800047b0:	00008067          	ret

800047b4 <print_timers>:

/* 打印定时器链表信息的调试函数 */
void print_timers(void)
{
800047b4:	fe010113          	addi	sp,sp,-32
800047b8:	00112e23          	sw	ra,28(sp)
800047bc:	00812c23          	sw	s0,24(sp)
800047c0:	02010413          	addi	s0,sp,32
    printf("\n=== Timer List Debug Info ===\n");
800047c4:	800067b7          	lui	a5,0x80006
800047c8:	acc78513          	addi	a0,a5,-1332 # 80005acc <_memory_end+0xf8005acc>
800047cc:	6bc000ef          	jal	ra,80004e88 <printf>
    printf("MTIMECMP:%d\n", get_mtimecmp());
800047d0:	d2dff0ef          	jal	ra,800044fc <get_mtimecmp>
800047d4:	00050793          	mv	a5,a0
800047d8:	00078593          	mv	a1,a5
800047dc:	800067b7          	lui	a5,0x80006
800047e0:	aec78513          	addi	a0,a5,-1300 # 80005aec <_memory_end+0xf8005aec>
800047e4:	6a4000ef          	jal	ra,80004e88 <printf>
    if (timers == NULL)
800047e8:	800067b7          	lui	a5,0x80006
800047ec:	0607a783          	lw	a5,96(a5) # 80006060 <_memory_end+0xf8006060>
800047f0:	00079a63          	bnez	a5,80004804 <print_timers+0x50>
    {
        printf("Timer list is empty\n");
800047f4:	800067b7          	lui	a5,0x80006
800047f8:	afc78513          	addi	a0,a5,-1284 # 80005afc <_memory_end+0xf8005afc>
800047fc:	68c000ef          	jal	ra,80004e88 <printf>
        return;
80004800:	1440006f          	j	80004944 <print_timers+0x190>
    }

    timer *current = timers;
80004804:	800067b7          	lui	a5,0x80006
80004808:	0607a783          	lw	a5,96(a5) # 80006060 <_memory_end+0xf8006060>
8000480c:	fef42623          	sw	a5,-20(s0)
    int count = 0;
80004810:	fe042423          	sw	zero,-24(s0)

    while (current != NULL)
80004814:	11c0006f          	j	80004930 <print_timers+0x17c>
    {
        printf("Timer[%d]:\n", count++);
80004818:	fe842783          	lw	a5,-24(s0)
8000481c:	00178713          	addi	a4,a5,1
80004820:	fee42423          	sw	a4,-24(s0)
80004824:	00078593          	mv	a1,a5
80004828:	800067b7          	lui	a5,0x80006
8000482c:	b1478513          	addi	a0,a5,-1260 # 80005b14 <_memory_end+0xf8005b14>
80004830:	658000ef          	jal	ra,80004e88 <printf>
        printf("  timeout_tick: %d\n", current->timeout_tick);
80004834:	fec42783          	lw	a5,-20(s0)
80004838:	0087a783          	lw	a5,8(a5)
8000483c:	00078593          	mv	a1,a5
80004840:	800067b7          	lui	a5,0x80006
80004844:	b2078513          	addi	a0,a5,-1248 # 80005b20 <_memory_end+0xf8005b20>
80004848:	640000ef          	jal	ra,80004e88 <printf>
        const char *func_name = "unknown";
8000484c:	800067b7          	lui	a5,0x80006
80004850:	b3478793          	addi	a5,a5,-1228 # 80005b34 <_memory_end+0xf8005b34>
80004854:	fef42223          	sw	a5,-28(s0)
        if (current->func == timer_handler)
80004858:	fec42783          	lw	a5,-20(s0)
8000485c:	0007a703          	lw	a4,0(a5)
80004860:	800047b7          	lui	a5,0x80004
80004864:	78478793          	addi	a5,a5,1924 # 80004784 <_memory_end+0xf8004784>
80004868:	00f71a63          	bne	a4,a5,8000487c <print_timers+0xc8>
        {
            func_name = "timer_handler";
8000486c:	800067b7          	lui	a5,0x80006
80004870:	b3c78793          	addi	a5,a5,-1220 # 80005b3c <_memory_end+0xf8005b3c>
80004874:	fef42223          	sw	a5,-28(s0)
80004878:	06c0006f          	j	800048e4 <print_timers+0x130>
        }
        else if (current->func == task_yield)
8000487c:	fec42783          	lw	a5,-20(s0)
80004880:	0007a703          	lw	a4,0(a5)
80004884:	800037b7          	lui	a5,0x80003
80004888:	a2078793          	addi	a5,a5,-1504 # 80002a20 <_memory_end+0xf8002a20>
8000488c:	00f71a63          	bne	a4,a5,800048a0 <print_timers+0xec>
        {
            func_name = "task_yield";
80004890:	800067b7          	lui	a5,0x80006
80004894:	b4c78793          	addi	a5,a5,-1204 # 80005b4c <_memory_end+0xf8005b4c>
80004898:	fef42223          	sw	a5,-28(s0)
8000489c:	0480006f          	j	800048e4 <print_timers+0x130>
        }
        else if (current->func == wake_up_task)
800048a0:	fec42783          	lw	a5,-20(s0)
800048a4:	0007a703          	lw	a4,0(a5)
800048a8:	800037b7          	lui	a5,0x80003
800048ac:	b8478793          	addi	a5,a5,-1148 # 80002b84 <_memory_end+0xf8002b84>
800048b0:	00f71a63          	bne	a4,a5,800048c4 <print_timers+0x110>
        {
            func_name = "wake_up_task";
800048b4:	800067b7          	lui	a5,0x80006
800048b8:	b5878793          	addi	a5,a5,-1192 # 80005b58 <_memory_end+0xf8005b58>
800048bc:	fef42223          	sw	a5,-28(s0)
800048c0:	0240006f          	j	800048e4 <print_timers+0x130>
        }
        else if (current->func == schedule)
800048c4:	fec42783          	lw	a5,-20(s0)
800048c8:	0007a703          	lw	a4,0(a5)
800048cc:	800027b7          	lui	a5,0x80002
800048d0:	48078793          	addi	a5,a5,1152 # 80002480 <_memory_end+0xf8002480>
800048d4:	00f71863          	bne	a4,a5,800048e4 <print_timers+0x130>
        {
            func_name = "schedule";
800048d8:	800067b7          	lui	a5,0x80006
800048dc:	b6878793          	addi	a5,a5,-1176 # 80005b68 <_memory_end+0xf8005b68>
800048e0:	fef42223          	sw	a5,-28(s0)
        }

        // ... 添加其他你需要识别的函数

        printf("  func name: %s\n", func_name);
800048e4:	fe442583          	lw	a1,-28(s0)
800048e8:	800067b7          	lui	a5,0x80006
800048ec:	b7478513          	addi	a0,a5,-1164 # 80005b74 <_memory_end+0xf8005b74>
800048f0:	598000ef          	jal	ra,80004e88 <printf>
        printf("  arg: %p\n", current->arg);
800048f4:	fec42783          	lw	a5,-20(s0)
800048f8:	0047a783          	lw	a5,4(a5)
800048fc:	00078593          	mv	a1,a5
80004900:	800067b7          	lui	a5,0x80006
80004904:	b8878513          	addi	a0,a5,-1144 # 80005b88 <_memory_end+0xf8005b88>
80004908:	580000ef          	jal	ra,80004e88 <printf>
        printf("  next: %p\n", (void *)current->next);
8000490c:	fec42783          	lw	a5,-20(s0)
80004910:	00c7a783          	lw	a5,12(a5)
80004914:	00078593          	mv	a1,a5
80004918:	800067b7          	lui	a5,0x80006
8000491c:	b9478513          	addi	a0,a5,-1132 # 80005b94 <_memory_end+0xf8005b94>
80004920:	568000ef          	jal	ra,80004e88 <printf>

        current = current->next;
80004924:	fec42783          	lw	a5,-20(s0)
80004928:	00c7a783          	lw	a5,12(a5)
8000492c:	fef42623          	sw	a5,-20(s0)
    while (current != NULL)
80004930:	fec42783          	lw	a5,-20(s0)
80004934:	ee0792e3          	bnez	a5,80004818 <print_timers+0x64>
    }
    printf("=== End of Timer List ===\n\n");
80004938:	800067b7          	lui	a5,0x80006
8000493c:	ba078513          	addi	a0,a5,-1120 # 80005ba0 <_memory_end+0xf8005ba0>
80004940:	548000ef          	jal	ra,80004e88 <printf>
80004944:	01c12083          	lw	ra,28(sp)
80004948:	01812403          	lw	s0,24(sp)
8000494c:	02010113          	addi	sp,sp,32
80004950:	00008067          	ret

80004954 <_vsnprintf>:
/*
 * ref: https://github.com/cccriscv/mini-riscv-os/blob/master/05-Preemptive/lib.c
 */

int _vsnprintf(char * out, size_t n, const char* s, va_list vl)
{
80004954:	fb010113          	addi	sp,sp,-80
80004958:	04812623          	sw	s0,76(sp)
8000495c:	05010413          	addi	s0,sp,80
80004960:	faa42e23          	sw	a0,-68(s0)
80004964:	fab42c23          	sw	a1,-72(s0)
80004968:	fac42a23          	sw	a2,-76(s0)
8000496c:	fad42823          	sw	a3,-80(s0)
	int format = 0;
80004970:	fe042623          	sw	zero,-20(s0)
	int longarg = 0;
80004974:	fe042423          	sw	zero,-24(s0)
	size_t pos = 0;
80004978:	fe042223          	sw	zero,-28(s0)
	for (; *s; s++) {
8000497c:	4080006f          	j	80004d84 <_vsnprintf+0x430>
		if (format) {
80004980:	fec42783          	lw	a5,-20(s0)
80004984:	38078c63          	beqz	a5,80004d1c <_vsnprintf+0x3c8>
			switch(*s) {
80004988:	fb442783          	lw	a5,-76(s0)
8000498c:	0007c783          	lbu	a5,0(a5)
80004990:	f9d78793          	addi	a5,a5,-99
80004994:	01500713          	li	a4,21
80004998:	3cf76e63          	bltu	a4,a5,80004d74 <_vsnprintf+0x420>
8000499c:	00279713          	slli	a4,a5,0x2
800049a0:	800067b7          	lui	a5,0x80006
800049a4:	bbc78793          	addi	a5,a5,-1092 # 80005bbc <_memory_end+0xf8005bbc>
800049a8:	00f707b3          	add	a5,a4,a5
800049ac:	0007a783          	lw	a5,0(a5)
800049b0:	00078067          	jr	a5
			case 'l': {
				longarg = 1;
800049b4:	00100793          	li	a5,1
800049b8:	fef42423          	sw	a5,-24(s0)
				break;
800049bc:	3bc0006f          	j	80004d78 <_vsnprintf+0x424>
			}
			case 'p': {
				longarg = 1;
800049c0:	00100793          	li	a5,1
800049c4:	fef42423          	sw	a5,-24(s0)
				if (out && pos < n) {
800049c8:	fbc42783          	lw	a5,-68(s0)
800049cc:	02078263          	beqz	a5,800049f0 <_vsnprintf+0x9c>
800049d0:	fe442703          	lw	a4,-28(s0)
800049d4:	fb842783          	lw	a5,-72(s0)
800049d8:	00f77c63          	bgeu	a4,a5,800049f0 <_vsnprintf+0x9c>
					out[pos] = '0';
800049dc:	fbc42703          	lw	a4,-68(s0)
800049e0:	fe442783          	lw	a5,-28(s0)
800049e4:	00f707b3          	add	a5,a4,a5
800049e8:	03000713          	li	a4,48
800049ec:	00e78023          	sb	a4,0(a5)
				}
				pos++;
800049f0:	fe442783          	lw	a5,-28(s0)
800049f4:	00178793          	addi	a5,a5,1
800049f8:	fef42223          	sw	a5,-28(s0)
				if (out && pos < n) {
800049fc:	fbc42783          	lw	a5,-68(s0)
80004a00:	02078263          	beqz	a5,80004a24 <_vsnprintf+0xd0>
80004a04:	fe442703          	lw	a4,-28(s0)
80004a08:	fb842783          	lw	a5,-72(s0)
80004a0c:	00f77c63          	bgeu	a4,a5,80004a24 <_vsnprintf+0xd0>
					out[pos] = 'x';
80004a10:	fbc42703          	lw	a4,-68(s0)
80004a14:	fe442783          	lw	a5,-28(s0)
80004a18:	00f707b3          	add	a5,a4,a5
80004a1c:	07800713          	li	a4,120
80004a20:	00e78023          	sb	a4,0(a5)
				}
				pos++;
80004a24:	fe442783          	lw	a5,-28(s0)
80004a28:	00178793          	addi	a5,a5,1
80004a2c:	fef42223          	sw	a5,-28(s0)
			}
			case 'x': {
				long num = longarg ? va_arg(vl, long) : va_arg(vl, int);
80004a30:	fe842783          	lw	a5,-24(s0)
80004a34:	00078c63          	beqz	a5,80004a4c <_vsnprintf+0xf8>
80004a38:	fb042783          	lw	a5,-80(s0)
80004a3c:	00478713          	addi	a4,a5,4
80004a40:	fae42823          	sw	a4,-80(s0)
80004a44:	0007a783          	lw	a5,0(a5)
80004a48:	0140006f          	j	80004a5c <_vsnprintf+0x108>
80004a4c:	fb042783          	lw	a5,-80(s0)
80004a50:	00478713          	addi	a4,a5,4
80004a54:	fae42823          	sw	a4,-80(s0)
80004a58:	0007a783          	lw	a5,0(a5)
80004a5c:	fcf42423          	sw	a5,-56(s0)
				int hexdigits = 2*(longarg ? sizeof(long) : sizeof(int))-1;
80004a60:	00700793          	li	a5,7
80004a64:	fcf42223          	sw	a5,-60(s0)
				for(int i = hexdigits; i >= 0; i--) {
80004a68:	fc442783          	lw	a5,-60(s0)
80004a6c:	fef42023          	sw	a5,-32(s0)
80004a70:	0880006f          	j	80004af8 <_vsnprintf+0x1a4>
					int d = (num >> (4*i)) & 0xF;
80004a74:	fe042783          	lw	a5,-32(s0)
80004a78:	00279793          	slli	a5,a5,0x2
80004a7c:	fc842703          	lw	a4,-56(s0)
80004a80:	40f757b3          	sra	a5,a4,a5
80004a84:	00f7f793          	andi	a5,a5,15
80004a88:	fcf42023          	sw	a5,-64(s0)
					if (out && pos < n) {
80004a8c:	fbc42783          	lw	a5,-68(s0)
80004a90:	04078863          	beqz	a5,80004ae0 <_vsnprintf+0x18c>
80004a94:	fe442703          	lw	a4,-28(s0)
80004a98:	fb842783          	lw	a5,-72(s0)
80004a9c:	04f77263          	bgeu	a4,a5,80004ae0 <_vsnprintf+0x18c>
						out[pos] = (d < 10 ? '0'+d : 'a'+d-10);
80004aa0:	fc042703          	lw	a4,-64(s0)
80004aa4:	00900793          	li	a5,9
80004aa8:	00e7cc63          	blt	a5,a4,80004ac0 <_vsnprintf+0x16c>
80004aac:	fc042783          	lw	a5,-64(s0)
80004ab0:	0ff7f793          	andi	a5,a5,255
80004ab4:	03078793          	addi	a5,a5,48
80004ab8:	0ff7f793          	andi	a5,a5,255
80004abc:	0140006f          	j	80004ad0 <_vsnprintf+0x17c>
80004ac0:	fc042783          	lw	a5,-64(s0)
80004ac4:	0ff7f793          	andi	a5,a5,255
80004ac8:	05778793          	addi	a5,a5,87
80004acc:	0ff7f793          	andi	a5,a5,255
80004ad0:	fbc42683          	lw	a3,-68(s0)
80004ad4:	fe442703          	lw	a4,-28(s0)
80004ad8:	00e68733          	add	a4,a3,a4
80004adc:	00f70023          	sb	a5,0(a4)
					}
					pos++;
80004ae0:	fe442783          	lw	a5,-28(s0)
80004ae4:	00178793          	addi	a5,a5,1
80004ae8:	fef42223          	sw	a5,-28(s0)
				for(int i = hexdigits; i >= 0; i--) {
80004aec:	fe042783          	lw	a5,-32(s0)
80004af0:	fff78793          	addi	a5,a5,-1
80004af4:	fef42023          	sw	a5,-32(s0)
80004af8:	fe042783          	lw	a5,-32(s0)
80004afc:	f607dce3          	bgez	a5,80004a74 <_vsnprintf+0x120>
				}
				longarg = 0;
80004b00:	fe042423          	sw	zero,-24(s0)
				format = 0;
80004b04:	fe042623          	sw	zero,-20(s0)
				break;
80004b08:	2700006f          	j	80004d78 <_vsnprintf+0x424>
			}
			case 'd': {
				long num = longarg ? va_arg(vl, long) : va_arg(vl, int);
80004b0c:	fe842783          	lw	a5,-24(s0)
80004b10:	00078c63          	beqz	a5,80004b28 <_vsnprintf+0x1d4>
80004b14:	fb042783          	lw	a5,-80(s0)
80004b18:	00478713          	addi	a4,a5,4
80004b1c:	fae42823          	sw	a4,-80(s0)
80004b20:	0007a783          	lw	a5,0(a5)
80004b24:	0140006f          	j	80004b38 <_vsnprintf+0x1e4>
80004b28:	fb042783          	lw	a5,-80(s0)
80004b2c:	00478713          	addi	a4,a5,4
80004b30:	fae42823          	sw	a4,-80(s0)
80004b34:	0007a783          	lw	a5,0(a5)
80004b38:	fcf42e23          	sw	a5,-36(s0)
				if (num < 0) {
80004b3c:	fdc42783          	lw	a5,-36(s0)
80004b40:	0407d263          	bgez	a5,80004b84 <_vsnprintf+0x230>
					num = -num;
80004b44:	fdc42783          	lw	a5,-36(s0)
80004b48:	40f007b3          	neg	a5,a5
80004b4c:	fcf42e23          	sw	a5,-36(s0)
					if (out && pos < n) {
80004b50:	fbc42783          	lw	a5,-68(s0)
80004b54:	02078263          	beqz	a5,80004b78 <_vsnprintf+0x224>
80004b58:	fe442703          	lw	a4,-28(s0)
80004b5c:	fb842783          	lw	a5,-72(s0)
80004b60:	00f77c63          	bgeu	a4,a5,80004b78 <_vsnprintf+0x224>
						out[pos] = '-';
80004b64:	fbc42703          	lw	a4,-68(s0)
80004b68:	fe442783          	lw	a5,-28(s0)
80004b6c:	00f707b3          	add	a5,a4,a5
80004b70:	02d00713          	li	a4,45
80004b74:	00e78023          	sb	a4,0(a5)
					}
					pos++;
80004b78:	fe442783          	lw	a5,-28(s0)
80004b7c:	00178793          	addi	a5,a5,1
80004b80:	fef42223          	sw	a5,-28(s0)
				}
				long digits = 1;
80004b84:	00100793          	li	a5,1
80004b88:	fcf42c23          	sw	a5,-40(s0)
				for (long nn = num; nn /= 10; digits++);
80004b8c:	fdc42783          	lw	a5,-36(s0)
80004b90:	fcf42a23          	sw	a5,-44(s0)
80004b94:	0100006f          	j	80004ba4 <_vsnprintf+0x250>
80004b98:	fd842783          	lw	a5,-40(s0)
80004b9c:	00178793          	addi	a5,a5,1
80004ba0:	fcf42c23          	sw	a5,-40(s0)
80004ba4:	fd442703          	lw	a4,-44(s0)
80004ba8:	00a00793          	li	a5,10
80004bac:	02f747b3          	div	a5,a4,a5
80004bb0:	fcf42a23          	sw	a5,-44(s0)
80004bb4:	fd442783          	lw	a5,-44(s0)
80004bb8:	fe0790e3          	bnez	a5,80004b98 <_vsnprintf+0x244>
				for (int i = digits-1; i >= 0; i--) {
80004bbc:	fd842783          	lw	a5,-40(s0)
80004bc0:	fff78793          	addi	a5,a5,-1
80004bc4:	fcf42823          	sw	a5,-48(s0)
80004bc8:	06c0006f          	j	80004c34 <_vsnprintf+0x2e0>
					if (out && pos + i < n) {
80004bcc:	fbc42783          	lw	a5,-68(s0)
80004bd0:	04078463          	beqz	a5,80004c18 <_vsnprintf+0x2c4>
80004bd4:	fd042703          	lw	a4,-48(s0)
80004bd8:	fe442783          	lw	a5,-28(s0)
80004bdc:	00f707b3          	add	a5,a4,a5
80004be0:	fb842703          	lw	a4,-72(s0)
80004be4:	02e7fa63          	bgeu	a5,a4,80004c18 <_vsnprintf+0x2c4>
						out[pos + i] = '0' + (num % 10);
80004be8:	fdc42703          	lw	a4,-36(s0)
80004bec:	00a00793          	li	a5,10
80004bf0:	02f767b3          	rem	a5,a4,a5
80004bf4:	0ff7f713          	andi	a4,a5,255
80004bf8:	fd042683          	lw	a3,-48(s0)
80004bfc:	fe442783          	lw	a5,-28(s0)
80004c00:	00f687b3          	add	a5,a3,a5
80004c04:	fbc42683          	lw	a3,-68(s0)
80004c08:	00f687b3          	add	a5,a3,a5
80004c0c:	03070713          	addi	a4,a4,48
80004c10:	0ff77713          	andi	a4,a4,255
80004c14:	00e78023          	sb	a4,0(a5)
					}
					num /= 10;
80004c18:	fdc42703          	lw	a4,-36(s0)
80004c1c:	00a00793          	li	a5,10
80004c20:	02f747b3          	div	a5,a4,a5
80004c24:	fcf42e23          	sw	a5,-36(s0)
				for (int i = digits-1; i >= 0; i--) {
80004c28:	fd042783          	lw	a5,-48(s0)
80004c2c:	fff78793          	addi	a5,a5,-1
80004c30:	fcf42823          	sw	a5,-48(s0)
80004c34:	fd042783          	lw	a5,-48(s0)
80004c38:	f807dae3          	bgez	a5,80004bcc <_vsnprintf+0x278>
				}
				pos += digits;
80004c3c:	fd842783          	lw	a5,-40(s0)
80004c40:	fe442703          	lw	a4,-28(s0)
80004c44:	00f707b3          	add	a5,a4,a5
80004c48:	fef42223          	sw	a5,-28(s0)
				longarg = 0;
80004c4c:	fe042423          	sw	zero,-24(s0)
				format = 0;
80004c50:	fe042623          	sw	zero,-20(s0)
				break;
80004c54:	1240006f          	j	80004d78 <_vsnprintf+0x424>
			}
			case 's': {
				const char* s2 = va_arg(vl, const char*);
80004c58:	fb042783          	lw	a5,-80(s0)
80004c5c:	00478713          	addi	a4,a5,4
80004c60:	fae42823          	sw	a4,-80(s0)
80004c64:	0007a783          	lw	a5,0(a5)
80004c68:	fcf42623          	sw	a5,-52(s0)
				while (*s2) {
80004c6c:	0480006f          	j	80004cb4 <_vsnprintf+0x360>
					if (out && pos < n) {
80004c70:	fbc42783          	lw	a5,-68(s0)
80004c74:	02078463          	beqz	a5,80004c9c <_vsnprintf+0x348>
80004c78:	fe442703          	lw	a4,-28(s0)
80004c7c:	fb842783          	lw	a5,-72(s0)
80004c80:	00f77e63          	bgeu	a4,a5,80004c9c <_vsnprintf+0x348>
						out[pos] = *s2;
80004c84:	fbc42703          	lw	a4,-68(s0)
80004c88:	fe442783          	lw	a5,-28(s0)
80004c8c:	00f707b3          	add	a5,a4,a5
80004c90:	fcc42703          	lw	a4,-52(s0)
80004c94:	00074703          	lbu	a4,0(a4)
80004c98:	00e78023          	sb	a4,0(a5)
					}
					pos++;
80004c9c:	fe442783          	lw	a5,-28(s0)
80004ca0:	00178793          	addi	a5,a5,1
80004ca4:	fef42223          	sw	a5,-28(s0)
					s2++;
80004ca8:	fcc42783          	lw	a5,-52(s0)
80004cac:	00178793          	addi	a5,a5,1
80004cb0:	fcf42623          	sw	a5,-52(s0)
				while (*s2) {
80004cb4:	fcc42783          	lw	a5,-52(s0)
80004cb8:	0007c783          	lbu	a5,0(a5)
80004cbc:	fa079ae3          	bnez	a5,80004c70 <_vsnprintf+0x31c>
				}
				longarg = 0;
80004cc0:	fe042423          	sw	zero,-24(s0)
				format = 0;
80004cc4:	fe042623          	sw	zero,-20(s0)
				break;
80004cc8:	0b00006f          	j	80004d78 <_vsnprintf+0x424>
			}
			case 'c': {
				if (out && pos < n) {
80004ccc:	fbc42783          	lw	a5,-68(s0)
80004cd0:	02078a63          	beqz	a5,80004d04 <_vsnprintf+0x3b0>
80004cd4:	fe442703          	lw	a4,-28(s0)
80004cd8:	fb842783          	lw	a5,-72(s0)
80004cdc:	02f77463          	bgeu	a4,a5,80004d04 <_vsnprintf+0x3b0>
					out[pos] = (char)va_arg(vl,int);
80004ce0:	fb042783          	lw	a5,-80(s0)
80004ce4:	00478713          	addi	a4,a5,4
80004ce8:	fae42823          	sw	a4,-80(s0)
80004cec:	0007a683          	lw	a3,0(a5)
80004cf0:	fbc42703          	lw	a4,-68(s0)
80004cf4:	fe442783          	lw	a5,-28(s0)
80004cf8:	00f707b3          	add	a5,a4,a5
80004cfc:	0ff6f713          	andi	a4,a3,255
80004d00:	00e78023          	sb	a4,0(a5)
				}
				pos++;
80004d04:	fe442783          	lw	a5,-28(s0)
80004d08:	00178793          	addi	a5,a5,1
80004d0c:	fef42223          	sw	a5,-28(s0)
				longarg = 0;
80004d10:	fe042423          	sw	zero,-24(s0)
				format = 0;
80004d14:	fe042623          	sw	zero,-20(s0)
				break;
80004d18:	0600006f          	j	80004d78 <_vsnprintf+0x424>
			}
			default:
				break;
			}
		} else if (*s == '%') {
80004d1c:	fb442783          	lw	a5,-76(s0)
80004d20:	0007c703          	lbu	a4,0(a5)
80004d24:	02500793          	li	a5,37
80004d28:	00f71863          	bne	a4,a5,80004d38 <_vsnprintf+0x3e4>
			format = 1;
80004d2c:	00100793          	li	a5,1
80004d30:	fef42623          	sw	a5,-20(s0)
80004d34:	0440006f          	j	80004d78 <_vsnprintf+0x424>
		} else {
			if (out && pos < n) {
80004d38:	fbc42783          	lw	a5,-68(s0)
80004d3c:	02078463          	beqz	a5,80004d64 <_vsnprintf+0x410>
80004d40:	fe442703          	lw	a4,-28(s0)
80004d44:	fb842783          	lw	a5,-72(s0)
80004d48:	00f77e63          	bgeu	a4,a5,80004d64 <_vsnprintf+0x410>
				out[pos] = *s;
80004d4c:	fbc42703          	lw	a4,-68(s0)
80004d50:	fe442783          	lw	a5,-28(s0)
80004d54:	00f707b3          	add	a5,a4,a5
80004d58:	fb442703          	lw	a4,-76(s0)
80004d5c:	00074703          	lbu	a4,0(a4)
80004d60:	00e78023          	sb	a4,0(a5)
			}
			pos++;
80004d64:	fe442783          	lw	a5,-28(s0)
80004d68:	00178793          	addi	a5,a5,1
80004d6c:	fef42223          	sw	a5,-28(s0)
80004d70:	0080006f          	j	80004d78 <_vsnprintf+0x424>
				break;
80004d74:	00000013          	nop
	for (; *s; s++) {
80004d78:	fb442783          	lw	a5,-76(s0)
80004d7c:	00178793          	addi	a5,a5,1
80004d80:	faf42a23          	sw	a5,-76(s0)
80004d84:	fb442783          	lw	a5,-76(s0)
80004d88:	0007c783          	lbu	a5,0(a5)
80004d8c:	be079ae3          	bnez	a5,80004980 <_vsnprintf+0x2c>
		}
    	}
	if (out && pos < n) {
80004d90:	fbc42783          	lw	a5,-68(s0)
80004d94:	02078263          	beqz	a5,80004db8 <_vsnprintf+0x464>
80004d98:	fe442703          	lw	a4,-28(s0)
80004d9c:	fb842783          	lw	a5,-72(s0)
80004da0:	00f77c63          	bgeu	a4,a5,80004db8 <_vsnprintf+0x464>
		out[pos] = 0;
80004da4:	fbc42703          	lw	a4,-68(s0)
80004da8:	fe442783          	lw	a5,-28(s0)
80004dac:	00f707b3          	add	a5,a4,a5
80004db0:	00078023          	sb	zero,0(a5)
80004db4:	0280006f          	j	80004ddc <_vsnprintf+0x488>
	} else if (out && n) {
80004db8:	fbc42783          	lw	a5,-68(s0)
80004dbc:	02078063          	beqz	a5,80004ddc <_vsnprintf+0x488>
80004dc0:	fb842783          	lw	a5,-72(s0)
80004dc4:	00078c63          	beqz	a5,80004ddc <_vsnprintf+0x488>
		out[n-1] = 0;
80004dc8:	fb842783          	lw	a5,-72(s0)
80004dcc:	fff78793          	addi	a5,a5,-1
80004dd0:	fbc42703          	lw	a4,-68(s0)
80004dd4:	00f707b3          	add	a5,a4,a5
80004dd8:	00078023          	sb	zero,0(a5)
	}
	return pos;
80004ddc:	fe442783          	lw	a5,-28(s0)
}
80004de0:	00078513          	mv	a0,a5
80004de4:	04c12403          	lw	s0,76(sp)
80004de8:	05010113          	addi	sp,sp,80
80004dec:	00008067          	ret

80004df0 <_vprintf>:

static char out_buf[1000]; // buffer for _vprintf()

int _vprintf(const char* s, va_list vl)
{
80004df0:	fd010113          	addi	sp,sp,-48
80004df4:	02112623          	sw	ra,44(sp)
80004df8:	02812423          	sw	s0,40(sp)
80004dfc:	03010413          	addi	s0,sp,48
80004e00:	fca42e23          	sw	a0,-36(s0)
80004e04:	fcb42c23          	sw	a1,-40(s0)
	int res = _vsnprintf(NULL, -1, s, vl);
80004e08:	fd842683          	lw	a3,-40(s0)
80004e0c:	fdc42603          	lw	a2,-36(s0)
80004e10:	fff00593          	li	a1,-1
80004e14:	00000513          	li	a0,0
80004e18:	b3dff0ef          	jal	ra,80004954 <_vsnprintf>
80004e1c:	fea42623          	sw	a0,-20(s0)
	if (res+1 >= sizeof(out_buf)) {
80004e20:	fec42783          	lw	a5,-20(s0)
80004e24:	00178793          	addi	a5,a5,1
80004e28:	00078713          	mv	a4,a5
80004e2c:	3e700793          	li	a5,999
80004e30:	00e7fa63          	bgeu	a5,a4,80004e44 <_vprintf+0x54>
		uart_puts("error: output string size overflow\n");
80004e34:	800067b7          	lui	a5,0x80006
80004e38:	c1478513          	addi	a0,a5,-1004 # 80005c14 <_memory_end+0xf8005c14>
80004e3c:	accff0ef          	jal	ra,80004108 <uart_puts>
		while(1) {}
80004e40:	0000006f          	j	80004e40 <_vprintf+0x50>
	}
	_vsnprintf(out_buf, res + 1, s, vl);
80004e44:	fec42783          	lw	a5,-20(s0)
80004e48:	00178793          	addi	a5,a5,1
80004e4c:	fd842683          	lw	a3,-40(s0)
80004e50:	fdc42603          	lw	a2,-36(s0)
80004e54:	00078593          	mv	a1,a5
80004e58:	80c067b7          	lui	a5,0x80c06
80004e5c:	72078513          	addi	a0,a5,1824 # 80c06720 <_memory_end+0xf8c06720>
80004e60:	af5ff0ef          	jal	ra,80004954 <_vsnprintf>
	uart_puts(out_buf);
80004e64:	80c067b7          	lui	a5,0x80c06
80004e68:	72078513          	addi	a0,a5,1824 # 80c06720 <_memory_end+0xf8c06720>
80004e6c:	a9cff0ef          	jal	ra,80004108 <uart_puts>
	return res;
80004e70:	fec42783          	lw	a5,-20(s0)
}
80004e74:	00078513          	mv	a0,a5
80004e78:	02c12083          	lw	ra,44(sp)
80004e7c:	02812403          	lw	s0,40(sp)
80004e80:	03010113          	addi	sp,sp,48
80004e84:	00008067          	ret

80004e88 <printf>:

int printf(const char* s, ...)
{
80004e88:	fb010113          	addi	sp,sp,-80
80004e8c:	02112623          	sw	ra,44(sp)
80004e90:	02812423          	sw	s0,40(sp)
80004e94:	03010413          	addi	s0,sp,48
80004e98:	fca42e23          	sw	a0,-36(s0)
80004e9c:	00b42223          	sw	a1,4(s0)
80004ea0:	00c42423          	sw	a2,8(s0)
80004ea4:	00d42623          	sw	a3,12(s0)
80004ea8:	00e42823          	sw	a4,16(s0)
80004eac:	00f42a23          	sw	a5,20(s0)
80004eb0:	01042c23          	sw	a6,24(s0)
80004eb4:	01142e23          	sw	a7,28(s0)
	int res = 0;
80004eb8:	fe042623          	sw	zero,-20(s0)
	va_list vl;
	va_start(vl, s);
80004ebc:	02040793          	addi	a5,s0,32
80004ec0:	fcf42c23          	sw	a5,-40(s0)
80004ec4:	fd842783          	lw	a5,-40(s0)
80004ec8:	fe478793          	addi	a5,a5,-28
80004ecc:	fef42423          	sw	a5,-24(s0)
	res = _vprintf(s, vl);
80004ed0:	fe842783          	lw	a5,-24(s0)
80004ed4:	00078593          	mv	a1,a5
80004ed8:	fdc42503          	lw	a0,-36(s0)
80004edc:	f15ff0ef          	jal	ra,80004df0 <_vprintf>
80004ee0:	fea42623          	sw	a0,-20(s0)
	va_end(vl);
	return res;
80004ee4:	fec42783          	lw	a5,-20(s0)
}
80004ee8:	00078513          	mv	a0,a5
80004eec:	02c12083          	lw	ra,44(sp)
80004ef0:	02812403          	lw	s0,40(sp)
80004ef4:	05010113          	addi	sp,sp,80
80004ef8:	00008067          	ret

80004efc <panic>:

void panic(char *s)
{
80004efc:	fe010113          	addi	sp,sp,-32
80004f00:	00112e23          	sw	ra,28(sp)
80004f04:	00812c23          	sw	s0,24(sp)
80004f08:	02010413          	addi	s0,sp,32
80004f0c:	fea42623          	sw	a0,-20(s0)
	printf("panic: ");
80004f10:	800067b7          	lui	a5,0x80006
80004f14:	c3878513          	addi	a0,a5,-968 # 80005c38 <_memory_end+0xf8005c38>
80004f18:	f71ff0ef          	jal	ra,80004e88 <printf>
	printf(s);
80004f1c:	fec42503          	lw	a0,-20(s0)
80004f20:	f69ff0ef          	jal	ra,80004e88 <printf>
	printf("\n");
80004f24:	800067b7          	lui	a5,0x80006
80004f28:	c4078513          	addi	a0,a5,-960 # 80005c40 <_memory_end+0xf8005c40>
80004f2c:	f5dff0ef          	jal	ra,80004e88 <printf>
	while(1){};
80004f30:	0000006f          	j	80004f30 <panic+0x34>

80004f34 <_vsprintf>:
}

// 将 _vsnprintf 包装为更容易使用的函数
int _vsprintf(char *out, const char *fmt, va_list vl)
{
80004f34:	fe010113          	addi	sp,sp,-32
80004f38:	00112e23          	sw	ra,28(sp)
80004f3c:	00812c23          	sw	s0,24(sp)
80004f40:	02010413          	addi	s0,sp,32
80004f44:	fea42623          	sw	a0,-20(s0)
80004f48:	feb42423          	sw	a1,-24(s0)
80004f4c:	fec42223          	sw	a2,-28(s0)
    return _vsnprintf(out, 256, fmt, vl);  // 假设最大 256 字节输出
80004f50:	fe442683          	lw	a3,-28(s0)
80004f54:	fe842603          	lw	a2,-24(s0)
80004f58:	10000593          	li	a1,256
80004f5c:	fec42503          	lw	a0,-20(s0)
80004f60:	9f5ff0ef          	jal	ra,80004954 <_vsnprintf>
80004f64:	00050793          	mv	a5,a0
}
80004f68:	00078513          	mv	a0,a5
80004f6c:	01c12083          	lw	ra,28(sp)
80004f70:	01812403          	lw	s0,24(sp)
80004f74:	02010113          	addi	sp,sp,32
80004f78:	00008067          	ret

80004f7c <insert_to_timer_list>:
#include "os.h"
timer *insert_to_timer_list(timer *timer_head, timer *_timer)
{
80004f7c:	fd010113          	addi	sp,sp,-48
80004f80:	02112623          	sw	ra,44(sp)
80004f84:	02812423          	sw	s0,40(sp)
80004f88:	03010413          	addi	s0,sp,48
80004f8c:	fca42e23          	sw	a0,-36(s0)
80004f90:	fcb42c23          	sw	a1,-40(s0)
    if (timer_head == NULL)
80004f94:	fdc42783          	lw	a5,-36(s0)
80004f98:	02079463          	bnez	a5,80004fc0 <insert_to_timer_list+0x44>
    {
        next_timer = _timer;
80004f9c:	800067b7          	lui	a5,0x80006
80004fa0:	fd842703          	lw	a4,-40(s0)
80004fa4:	06e7a223          	sw	a4,100(a5) # 80006064 <_memory_end+0xf8006064>
        timer_load(_timer->timeout_tick);
80004fa8:	fd842783          	lw	a5,-40(s0)
80004fac:	0087a783          	lw	a5,8(a5)
80004fb0:	00078513          	mv	a0,a5
80004fb4:	cd4ff0ef          	jal	ra,80004488 <timer_load>
        return _timer;
80004fb8:	fd842783          	lw	a5,-40(s0)
80004fbc:	1400006f          	j	800050fc <insert_to_timer_list+0x180>
    }
    if (timer_head->timeout_tick > _timer->timeout_tick)
80004fc0:	fdc42783          	lw	a5,-36(s0)
80004fc4:	0087a703          	lw	a4,8(a5)
80004fc8:	fd842783          	lw	a5,-40(s0)
80004fcc:	0087a783          	lw	a5,8(a5)
80004fd0:	02e7fa63          	bgeu	a5,a4,80005004 <insert_to_timer_list+0x88>
    {
        _timer->next = timer_head;
80004fd4:	fd842783          	lw	a5,-40(s0)
80004fd8:	fdc42703          	lw	a4,-36(s0)
80004fdc:	00e7a623          	sw	a4,12(a5)
        next_timer = _timer;
80004fe0:	800067b7          	lui	a5,0x80006
80004fe4:	fd842703          	lw	a4,-40(s0)
80004fe8:	06e7a223          	sw	a4,100(a5) # 80006064 <_memory_end+0xf8006064>
        timer_load(_timer->timeout_tick);
80004fec:	fd842783          	lw	a5,-40(s0)
80004ff0:	0087a783          	lw	a5,8(a5)
80004ff4:	00078513          	mv	a0,a5
80004ff8:	c90ff0ef          	jal	ra,80004488 <timer_load>
        return _timer;
80004ffc:	fd842783          	lw	a5,-40(s0)
80005000:	0fc0006f          	j	800050fc <insert_to_timer_list+0x180>
    }

    timer *current_timer = timer_head;
80005004:	fdc42783          	lw	a5,-36(s0)
80005008:	fef42623          	sw	a5,-20(s0)
    timer_load(timer_head->timeout_tick);
8000500c:	fdc42783          	lw	a5,-36(s0)
80005010:	0087a783          	lw	a5,8(a5)
80005014:	00078513          	mv	a0,a5
80005018:	c70ff0ef          	jal	ra,80004488 <timer_load>
    while (current_timer->next != NULL)
8000501c:	0840006f          	j	800050a0 <insert_to_timer_list+0x124>
    {
        if (current_timer->next->timeout_tick > _timer->timeout_tick && current_timer->timeout_tick < _timer->timeout_tick)
80005020:	fec42783          	lw	a5,-20(s0)
80005024:	00c7a783          	lw	a5,12(a5)
80005028:	0087a703          	lw	a4,8(a5)
8000502c:	fd842783          	lw	a5,-40(s0)
80005030:	0087a783          	lw	a5,8(a5)
80005034:	06e7f063          	bgeu	a5,a4,80005094 <insert_to_timer_list+0x118>
80005038:	fec42783          	lw	a5,-20(s0)
8000503c:	0087a703          	lw	a4,8(a5)
80005040:	fd842783          	lw	a5,-40(s0)
80005044:	0087a783          	lw	a5,8(a5)
80005048:	04f77663          	bgeu	a4,a5,80005094 <insert_to_timer_list+0x118>
        {
            _timer->next = current_timer->next;
8000504c:	fec42783          	lw	a5,-20(s0)
80005050:	00c7a703          	lw	a4,12(a5)
80005054:	fd842783          	lw	a5,-40(s0)
80005058:	00e7a623          	sw	a4,12(a5)
            current_timer->next = _timer;
8000505c:	fec42783          	lw	a5,-20(s0)
80005060:	fd842703          	lw	a4,-40(s0)
80005064:	00e7a623          	sw	a4,12(a5)

            if (_timer->timeout_tick < next_timer->timeout_tick)
80005068:	fd842783          	lw	a5,-40(s0)
8000506c:	0087a703          	lw	a4,8(a5)
80005070:	800067b7          	lui	a5,0x80006
80005074:	0647a783          	lw	a5,100(a5) # 80006064 <_memory_end+0xf8006064>
80005078:	0087a783          	lw	a5,8(a5)
8000507c:	00f77863          	bgeu	a4,a5,8000508c <insert_to_timer_list+0x110>
            {
                next_timer = _timer;
80005080:	800067b7          	lui	a5,0x80006
80005084:	fd842703          	lw	a4,-40(s0)
80005088:	06e7a223          	sw	a4,100(a5) # 80006064 <_memory_end+0xf8006064>
            }
            return timer_head;
8000508c:	fdc42783          	lw	a5,-36(s0)
80005090:	06c0006f          	j	800050fc <insert_to_timer_list+0x180>
        }
        current_timer = current_timer->next;
80005094:	fec42783          	lw	a5,-20(s0)
80005098:	00c7a783          	lw	a5,12(a5)
8000509c:	fef42623          	sw	a5,-20(s0)
    while (current_timer->next != NULL)
800050a0:	fec42783          	lw	a5,-20(s0)
800050a4:	00c7a783          	lw	a5,12(a5)
800050a8:	f6079ce3          	bnez	a5,80005020 <insert_to_timer_list+0xa4>
    }
    current_timer->next = _timer;
800050ac:	fec42783          	lw	a5,-20(s0)
800050b0:	fd842703          	lw	a4,-40(s0)
800050b4:	00e7a623          	sw	a4,12(a5)
    if (next_timer == NULL || (_timer->timeout_tick < next_timer->timeout_tick))
800050b8:	800067b7          	lui	a5,0x80006
800050bc:	0647a783          	lw	a5,100(a5) # 80006064 <_memory_end+0xf8006064>
800050c0:	00078e63          	beqz	a5,800050dc <insert_to_timer_list+0x160>
800050c4:	fd842783          	lw	a5,-40(s0)
800050c8:	0087a703          	lw	a4,8(a5)
800050cc:	800067b7          	lui	a5,0x80006
800050d0:	0647a783          	lw	a5,100(a5) # 80006064 <_memory_end+0xf8006064>
800050d4:	0087a783          	lw	a5,8(a5)
800050d8:	00f77863          	bgeu	a4,a5,800050e8 <insert_to_timer_list+0x16c>
    {
        next_timer = _timer;
800050dc:	800067b7          	lui	a5,0x80006
800050e0:	fd842703          	lw	a4,-40(s0)
800050e4:	06e7a223          	sw	a4,100(a5) # 80006064 <_memory_end+0xf8006064>
    }
    timer_load(timer_head->timeout_tick);
800050e8:	fdc42783          	lw	a5,-36(s0)
800050ec:	0087a783          	lw	a5,8(a5)
800050f0:	00078513          	mv	a0,a5
800050f4:	b94ff0ef          	jal	ra,80004488 <timer_load>

    return timer_head;
800050f8:	fdc42783          	lw	a5,-36(s0)
}
800050fc:	00078513          	mv	a0,a5
80005100:	02c12083          	lw	ra,44(sp)
80005104:	02812403          	lw	s0,40(sp)
80005108:	03010113          	addi	sp,sp,48
8000510c:	00008067          	ret

80005110 <delete_from_timer_list>:

timer *delete_from_timer_list(timer *timer_head, timer *_timer)
{
80005110:	fd010113          	addi	sp,sp,-48
80005114:	02812623          	sw	s0,44(sp)
80005118:	03010413          	addi	s0,sp,48
8000511c:	fca42e23          	sw	a0,-36(s0)
80005120:	fcb42c23          	sw	a1,-40(s0)
    if (timer_head == NULL)
80005124:	fdc42783          	lw	a5,-36(s0)
80005128:	00079663          	bnez	a5,80005134 <delete_from_timer_list+0x24>
        return NULL;
8000512c:	00000793          	li	a5,0
80005130:	0b40006f          	j	800051e4 <delete_from_timer_list+0xd4>
    if (timer_head == _timer)
80005134:	fdc42703          	lw	a4,-36(s0)
80005138:	fd842783          	lw	a5,-40(s0)
8000513c:	02f71a63          	bne	a4,a5,80005170 <delete_from_timer_list+0x60>
    {
        timer *new_head = timer_head->next;
80005140:	fdc42783          	lw	a5,-36(s0)
80005144:	00c7a783          	lw	a5,12(a5)
80005148:	fef42423          	sw	a5,-24(s0)
        if (next_timer == timer_head)
8000514c:	800067b7          	lui	a5,0x80006
80005150:	0647a783          	lw	a5,100(a5) # 80006064 <_memory_end+0xf8006064>
80005154:	fdc42703          	lw	a4,-36(s0)
80005158:	00f71863          	bne	a4,a5,80005168 <delete_from_timer_list+0x58>
        {
            next_timer = new_head;
8000515c:	800067b7          	lui	a5,0x80006
80005160:	fe842703          	lw	a4,-24(s0)
80005164:	06e7a223          	sw	a4,100(a5) # 80006064 <_memory_end+0xf8006064>
        }
        return new_head;
80005168:	fe842783          	lw	a5,-24(s0)
8000516c:	0780006f          	j	800051e4 <delete_from_timer_list+0xd4>
    }
    timer *current_timer = timer_head;
80005170:	fdc42783          	lw	a5,-36(s0)
80005174:	fef42623          	sw	a5,-20(s0)
    while (current_timer->next != NULL)
80005178:	05c0006f          	j	800051d4 <delete_from_timer_list+0xc4>
    {
        if (current_timer->next == _timer)
8000517c:	fec42783          	lw	a5,-20(s0)
80005180:	00c7a783          	lw	a5,12(a5)
80005184:	fd842703          	lw	a4,-40(s0)
80005188:	04f71063          	bne	a4,a5,800051c8 <delete_from_timer_list+0xb8>
        {
            current_timer->next = current_timer->next->next;
8000518c:	fec42783          	lw	a5,-20(s0)
80005190:	00c7a783          	lw	a5,12(a5)
80005194:	00c7a703          	lw	a4,12(a5)
80005198:	fec42783          	lw	a5,-20(s0)
8000519c:	00e7a623          	sw	a4,12(a5)
            if (next_timer == _timer)
800051a0:	800067b7          	lui	a5,0x80006
800051a4:	0647a783          	lw	a5,100(a5) # 80006064 <_memory_end+0xf8006064>
800051a8:	fd842703          	lw	a4,-40(s0)
800051ac:	00f71a63          	bne	a4,a5,800051c0 <delete_from_timer_list+0xb0>
            {
                next_timer = current_timer->next;
800051b0:	fec42783          	lw	a5,-20(s0)
800051b4:	00c7a703          	lw	a4,12(a5)
800051b8:	800067b7          	lui	a5,0x80006
800051bc:	06e7a223          	sw	a4,100(a5) # 80006064 <_memory_end+0xf8006064>
            }
            return timer_head;
800051c0:	fdc42783          	lw	a5,-36(s0)
800051c4:	0200006f          	j	800051e4 <delete_from_timer_list+0xd4>
        }
        current_timer = current_timer->next;
800051c8:	fec42783          	lw	a5,-20(s0)
800051cc:	00c7a783          	lw	a5,12(a5)
800051d0:	fef42623          	sw	a5,-20(s0)
    while (current_timer->next != NULL)
800051d4:	fec42783          	lw	a5,-20(s0)
800051d8:	00c7a783          	lw	a5,12(a5)
800051dc:	fa0790e3          	bnez	a5,8000517c <delete_from_timer_list+0x6c>
    }
    return timer_head;
800051e0:	fdc42783          	lw	a5,-36(s0)
}
800051e4:	00078513          	mv	a0,a5
800051e8:	02c12403          	lw	s0,44(sp)
800051ec:	03010113          	addi	sp,sp,48
800051f0:	00008067          	ret

800051f4 <just_while>:
#include "include/user/user_syscall.h"

#define DELAY 1

void just_while(void)
{
800051f4:	ff010113          	addi	sp,sp,-16
800051f8:	00812623          	sw	s0,12(sp)
800051fc:	01010413          	addi	s0,sp,16
	while (1)
80005200:	0000006f          	j	80005200 <just_while+0xc>

80005204 <user_task0>:
		;
	}
}

void user_task0(void *param)
{
80005204:	fe010113          	addi	sp,sp,-32
80005208:	00112e23          	sw	ra,28(sp)
8000520c:	00812c23          	sw	s0,24(sp)
80005210:	02010413          	addi	s0,sp,32
80005214:	fea42623          	sw	a0,-20(s0)
	uart_puts("Task 0: Created!\n");
80005218:	800067b7          	lui	a5,0x80006
8000521c:	c4478513          	addi	a0,a5,-956 # 80005c44 <_memory_end+0xf8005c44>
80005220:	ee9fe0ef          	jal	ra,80004108 <uart_puts>
	while (1)
	{
		uart_puts("Task 0: Running...\n");
80005224:	800067b7          	lui	a5,0x80006
80005228:	c5878513          	addi	a0,a5,-936 # 80005c58 <_memory_end+0xf8005c58>
8000522c:	eddfe0ef          	jal	ra,80004108 <uart_puts>
		task_delay(DELAY);
80005230:	00100513          	li	a0,1
80005234:	9d1fd0ef          	jal	ra,80002c04 <task_delay>
		uart_puts("Task 0: Running...\n");
80005238:	fedff06f          	j	80005224 <user_task0+0x20>

8000523c <user_task1>:
	}
}

void user_task1(void *param)
{
8000523c:	fe010113          	addi	sp,sp,-32
80005240:	00112e23          	sw	ra,28(sp)
80005244:	00812c23          	sw	s0,24(sp)
80005248:	02010413          	addi	s0,sp,32
8000524c:	fea42623          	sw	a0,-20(s0)
	uart_puts("Task 1: Created!\n");
80005250:	800067b7          	lui	a5,0x80006
80005254:	c6c78513          	addi	a0,a5,-916 # 80005c6c <_memory_end+0xf8005c6c>
80005258:	eb1fe0ef          	jal	ra,80004108 <uart_puts>
	while (1)
	{
		uart_puts("Task 1: Running...\n");
8000525c:	800067b7          	lui	a5,0x80006
80005260:	c8078513          	addi	a0,a5,-896 # 80005c80 <_memory_end+0xf8005c80>
80005264:	ea5fe0ef          	jal	ra,80004108 <uart_puts>
		task_delay(DELAY);
80005268:	00100513          	li	a0,1
8000526c:	999fd0ef          	jal	ra,80002c04 <task_delay>
		uart_puts("Task 1: Running...\n");
80005270:	fedff06f          	j	8000525c <user_task1+0x20>

80005274 <user_task>:
	}
}

void user_task(void *param)
{
80005274:	fd010113          	addi	sp,sp,-48
80005278:	02112623          	sw	ra,44(sp)
8000527c:	02812423          	sw	s0,40(sp)
80005280:	03010413          	addi	s0,sp,48
80005284:	fca42e23          	sw	a0,-36(s0)
	int task_id = (int)param;
80005288:	fdc42783          	lw	a5,-36(s0)
8000528c:	fef42423          	sw	a5,-24(s0)
	printf("Task %d: Created!\n", task_id);
80005290:	fe842583          	lw	a1,-24(s0)
80005294:	800067b7          	lui	a5,0x80006
80005298:	c9478513          	addi	a0,a5,-876 # 80005c94 <_memory_end+0xf8005c94>
8000529c:	bedff0ef          	jal	ra,80004e88 <printf>
	int iter_cnt = task_id;
800052a0:	fe842783          	lw	a5,-24(s0)
800052a4:	fef42623          	sw	a5,-20(s0)
	while (1)
	{
		printf("Task %d: Running...\n", task_id);
800052a8:	fe842583          	lw	a1,-24(s0)
800052ac:	800067b7          	lui	a5,0x80006
800052b0:	ca878513          	addi	a0,a5,-856 # 80005ca8 <_memory_end+0xf8005ca8>
800052b4:	bd5ff0ef          	jal	ra,80004e88 <printf>
		task_delay(DELAY);
800052b8:	00100513          	li	a0,1
800052bc:	949fd0ef          	jal	ra,80002c04 <task_delay>
		if (iter_cnt-- == 0)
800052c0:	fec42783          	lw	a5,-20(s0)
800052c4:	fff78713          	addi	a4,a5,-1
800052c8:	fee42623          	sw	a4,-20(s0)
800052cc:	00078463          	beqz	a5,800052d4 <user_task+0x60>
		printf("Task %d: Running...\n", task_id);
800052d0:	fd9ff06f          	j	800052a8 <user_task+0x34>
		{
			break;
800052d4:	00000013          	nop
		}
	}
	printf("Task %d: Finished!\n", task_id);
800052d8:	fe842583          	lw	a1,-24(s0)
800052dc:	800067b7          	lui	a5,0x80006
800052e0:	cc078513          	addi	a0,a5,-832 # 80005cc0 <_memory_end+0xf8005cc0>
800052e4:	ba5ff0ef          	jal	ra,80004e88 <printf>
	task_exit();
800052e8:	ffcfd0ef          	jal	ra,80002ae4 <task_exit>
}
800052ec:	00000013          	nop
800052f0:	02c12083          	lw	ra,44(sp)
800052f4:	02812403          	lw	s0,40(sp)
800052f8:	03010113          	addi	sp,sp,48
800052fc:	00008067          	ret

80005300 <user_syscall_task>:

void user_syscall_task(void *param)
{
80005300:	fd010113          	addi	sp,sp,-48
80005304:	02112623          	sw	ra,44(sp)
80005308:	02812423          	sw	s0,40(sp)
8000530c:	03010413          	addi	s0,sp,48
80005310:	fca42e23          	sw	a0,-36(s0)
	int task_id = (int)param;
80005314:	fdc42783          	lw	a5,-36(s0)
80005318:	fef42423          	sw	a5,-24(s0)
	u_uart_puts("User Syscall Task: Started!\n");
8000531c:	800067b7          	lui	a5,0x80006
80005320:	cd478513          	addi	a0,a5,-812 # 80005cd4 <_memory_end+0xf8005cd4>
80005324:	30c000ef          	jal	ra,80005630 <u_uart_puts>

	// 使用系统调用接口打印
	u_printf("Task %d: 使用系统调用接口\n", task_id);
80005328:	fe842583          	lw	a1,-24(s0)
8000532c:	800067b7          	lui	a5,0x80006
80005330:	cf478513          	addi	a0,a5,-780 # 80005cf4 <_memory_end+0xf8005cf4>
80005334:	26c000ef          	jal	ra,800055a0 <u_printf>

	for (int i = 0; i < 3; i++)
80005338:	fe042623          	sw	zero,-20(s0)
8000533c:	0380006f          	j	80005374 <user_syscall_task+0x74>
	{
		uart_puts("Task 2: Running...\n");
80005340:	800067b7          	lui	a5,0x80006
80005344:	d1878513          	addi	a0,a5,-744 # 80005d18 <_memory_end+0xf8005d18>
80005348:	dc1fe0ef          	jal	ra,80004108 <uart_puts>
		u_printf("Task %d: 迭代 %d\n", task_id, i);
8000534c:	fec42603          	lw	a2,-20(s0)
80005350:	fe842583          	lw	a1,-24(s0)
80005354:	800067b7          	lui	a5,0x80006
80005358:	d2c78513          	addi	a0,a5,-724 # 80005d2c <_memory_end+0xf8005d2c>
8000535c:	244000ef          	jal	ra,800055a0 <u_printf>
		u_task_delay(1); // 使用系统调用接口延迟
80005360:	00100513          	li	a0,1
80005364:	1a0000ef          	jal	ra,80005504 <u_task_delay>
	for (int i = 0; i < 3; i++)
80005368:	fec42783          	lw	a5,-20(s0)
8000536c:	00178793          	addi	a5,a5,1
80005370:	fef42623          	sw	a5,-20(s0)
80005374:	fec42703          	lw	a4,-20(s0)
80005378:	00200793          	li	a5,2
8000537c:	fce7d2e3          	bge	a5,a4,80005340 <user_syscall_task+0x40>
	}

	// 分配内存测试
	void *mem = u_malloc(64);
80005380:	04000513          	li	a0,64
80005384:	1b0000ef          	jal	ra,80005534 <u_malloc>
80005388:	fea42223          	sw	a0,-28(s0)
	if (mem != NULL)
8000538c:	fe442783          	lw	a5,-28(s0)
80005390:	02078063          	beqz	a5,800053b0 <user_syscall_task+0xb0>
	{
		u_printf("Task %d: 内存分配成功: %p\n", task_id, mem);
80005394:	fe442603          	lw	a2,-28(s0)
80005398:	fe842583          	lw	a1,-24(s0)
8000539c:	800067b7          	lui	a5,0x80006
800053a0:	d4078513          	addi	a0,a5,-704 # 80005d40 <_memory_end+0xf8005d40>
800053a4:	1fc000ef          	jal	ra,800055a0 <u_printf>
		u_free(mem); // 释放内存
800053a8:	fe442503          	lw	a0,-28(s0)
800053ac:	1c4000ef          	jal	ra,80005570 <u_free>
	}

	u_uart_puts("User Syscall Task: 完成!\n");
800053b0:	800067b7          	lui	a5,0x80006
800053b4:	d6478513          	addi	a0,a5,-668 # 80005d64 <_memory_end+0xf8005d64>
800053b8:	278000ef          	jal	ra,80005630 <u_uart_puts>
	u_task_exit(); // 使用系统调用接口退出
800053bc:	124000ef          	jal	ra,800054e0 <u_task_exit>
}
800053c0:	00000013          	nop
800053c4:	02c12083          	lw	ra,44(sp)
800053c8:	02812403          	lw	s0,40(sp)
800053cc:	03010113          	addi	sp,sp,48
800053d0:	00008067          	ret

800053d4 <os_main>:

/* NOTICE: DON'T LOOP INFINITELY IN main() */
void os_main(void)
{
800053d4:	ff010113          	addi	sp,sp,-16
800053d8:	00112623          	sw	ra,12(sp)
800053dc:	00812423          	sw	s0,8(sp)
800053e0:	01010413          	addi	s0,sp,16
	// 直接使用内核API创建所有任务
	task_create(just_while, NULL, 129, DEFAULT_TIMESLICE);
800053e4:	00200693          	li	a3,2
800053e8:	08100613          	li	a2,129
800053ec:	00000593          	li	a1,0
800053f0:	800057b7          	lui	a5,0x80005
800053f4:	1f478513          	addi	a0,a5,500 # 800051f4 <_memory_end+0xf80051f4>
800053f8:	bfcfd0ef          	jal	ra,800027f4 <task_create>
	task_create(user_task0, NULL, 128, DEFAULT_TIMESLICE);
800053fc:	00200693          	li	a3,2
80005400:	08000613          	li	a2,128
80005404:	00000593          	li	a1,0
80005408:	800057b7          	lui	a5,0x80005
8000540c:	20478513          	addi	a0,a5,516 # 80005204 <_memory_end+0xf8005204>
80005410:	be4fd0ef          	jal	ra,800027f4 <task_create>
	task_create(user_task1, NULL, 128, DEFAULT_TIMESLICE);
80005414:	00200693          	li	a3,2
80005418:	08000613          	li	a2,128
8000541c:	00000593          	li	a1,0
80005420:	800057b7          	lui	a5,0x80005
80005424:	23c78513          	addi	a0,a5,572 # 8000523c <_memory_end+0xf800523c>
80005428:	bccfd0ef          	jal	ra,800027f4 <task_create>
	task_create(user_syscall_task, (void *)2, 3, DEFAULT_TIMESLICE);
8000542c:	00200693          	li	a3,2
80005430:	00300613          	li	a2,3
80005434:	00200593          	li	a1,2
80005438:	800057b7          	lui	a5,0x80005
8000543c:	30078513          	addi	a0,a5,768 # 80005300 <_memory_end+0xf8005300>
80005440:	bb4fd0ef          	jal	ra,800027f4 <task_create>
80005444:	00000013          	nop
80005448:	00c12083          	lw	ra,12(sp)
8000544c:	00812403          	lw	s0,8(sp)
80005450:	01010113          	addi	sp,sp,16
80005454:	00008067          	ret

80005458 <u_task_create>:
#include "syscall.h"
#include "os.h"

// 用户态系统调用包装函数
int u_task_create(void (*start_routine)(void*), void *param, unsigned char priority, unsigned int timeslice)
{
80005458:	fd010113          	addi	sp,sp,-48
8000545c:	02812623          	sw	s0,44(sp)
80005460:	03010413          	addi	s0,sp,48
80005464:	fca42e23          	sw	a0,-36(s0)
80005468:	fcb42c23          	sw	a1,-40(s0)
8000546c:	00060793          	mv	a5,a2
80005470:	fcd42823          	sw	a3,-48(s0)
80005474:	fcf40ba3          	sb	a5,-41(s0)
    int ret;
    asm volatile(
80005478:	fdc42783          	lw	a5,-36(s0)
8000547c:	fd842703          	lw	a4,-40(s0)
80005480:	fd744803          	lbu	a6,-41(s0)
80005484:	fd042303          	lw	t1,-48(s0)
80005488:	00100893          	li	a7,1
8000548c:	00078513          	mv	a0,a5
80005490:	00070593          	mv	a1,a4
80005494:	00080613          	mv	a2,a6
80005498:	00030693          	mv	a3,t1
8000549c:	00000073          	ecall
800054a0:	00050793          	mv	a5,a0
800054a4:	fef42623          	sw	a5,-20(s0)
        "ecall\n"
        "mv %0, a0"
        : "=r"(ret)
        : "i"(SYS_task_create), "r"(start_routine), "r"(param), "r"(priority), "r"(timeslice)
        : "a0", "a1", "a2", "a3", "a7");
    return ret;
800054a8:	fec42783          	lw	a5,-20(s0)
}
800054ac:	00078513          	mv	a0,a5
800054b0:	02c12403          	lw	s0,44(sp)
800054b4:	03010113          	addi	sp,sp,48
800054b8:	00008067          	ret

800054bc <u_task_yield>:

void u_task_yield(void)
{
800054bc:	ff010113          	addi	sp,sp,-16
800054c0:	00812623          	sw	s0,12(sp)
800054c4:	01010413          	addi	s0,sp,16
    asm volatile(
800054c8:	00200893          	li	a7,2
800054cc:	00000073          	ecall
        "li a7, %0\n"
        "ecall"
        :
        : "i"(SYS_task_yield)
        : "a7");
}
800054d0:	00000013          	nop
800054d4:	00c12403          	lw	s0,12(sp)
800054d8:	01010113          	addi	sp,sp,16
800054dc:	00008067          	ret

800054e0 <u_task_exit>:

void u_task_exit(void)
{
800054e0:	ff010113          	addi	sp,sp,-16
800054e4:	00812623          	sw	s0,12(sp)
800054e8:	01010413          	addi	s0,sp,16
    asm volatile(
800054ec:	00300893          	li	a7,3
800054f0:	00000073          	ecall
        "li a7, %0\n"
        "ecall"
        :
        : "i"(SYS_task_exit)
        : "a7");
}
800054f4:	00000013          	nop
800054f8:	00c12403          	lw	s0,12(sp)
800054fc:	01010113          	addi	sp,sp,16
80005500:	00008067          	ret

80005504 <u_task_delay>:

void u_task_delay(unsigned int count)
{
80005504:	fe010113          	addi	sp,sp,-32
80005508:	00812e23          	sw	s0,28(sp)
8000550c:	02010413          	addi	s0,sp,32
80005510:	fea42623          	sw	a0,-20(s0)
    asm volatile(
80005514:	fec42783          	lw	a5,-20(s0)
80005518:	00400893          	li	a7,4
8000551c:	00078513          	mv	a0,a5
80005520:	00000073          	ecall
        "mv a0, %0\n"
        "ecall"
        :
        : "r"(count), "i"(SYS_task_delay)
        : "a0", "a7");
}
80005524:	00000013          	nop
80005528:	01c12403          	lw	s0,28(sp)
8000552c:	02010113          	addi	sp,sp,32
80005530:	00008067          	ret

80005534 <u_malloc>:

void* u_malloc(size_t size)
{
80005534:	fd010113          	addi	sp,sp,-48
80005538:	02812623          	sw	s0,44(sp)
8000553c:	03010413          	addi	s0,sp,48
80005540:	fca42e23          	sw	a0,-36(s0)
    void* ret;
    asm volatile(
80005544:	fdc42783          	lw	a5,-36(s0)
80005548:	00500893          	li	a7,5
8000554c:	00078513          	mv	a0,a5
80005550:	00000073          	ecall
80005554:	00050793          	mv	a5,a0
80005558:	fef42623          	sw	a5,-20(s0)
        "ecall\n"
        "mv %0, a0"
        : "=r"(ret)
        : "i"(SYS_malloc), "r"(size)
        : "a0", "a7");
    return ret;
8000555c:	fec42783          	lw	a5,-20(s0)
}
80005560:	00078513          	mv	a0,a5
80005564:	02c12403          	lw	s0,44(sp)
80005568:	03010113          	addi	sp,sp,48
8000556c:	00008067          	ret

80005570 <u_free>:

void u_free(void *ptr)
{
80005570:	fe010113          	addi	sp,sp,-32
80005574:	00812e23          	sw	s0,28(sp)
80005578:	02010413          	addi	s0,sp,32
8000557c:	fea42623          	sw	a0,-20(s0)
    asm volatile(
80005580:	fec42783          	lw	a5,-20(s0)
80005584:	00600893          	li	a7,6
80005588:	00078513          	mv	a0,a5
8000558c:	00000073          	ecall
        "mv a0, %0\n"
        "ecall"
        :
        : "r"(ptr), "i"(SYS_free)
        : "a0", "a7");
}
80005590:	00000013          	nop
80005594:	01c12403          	lw	s0,28(sp)
80005598:	02010113          	addi	sp,sp,32
8000559c:	00008067          	ret

800055a0 <u_printf>:

// 替换现有的 u_printf 实现
int u_printf(const char *format, ...)
{
800055a0:	eb010113          	addi	sp,sp,-336
800055a4:	12112623          	sw	ra,300(sp)
800055a8:	12812423          	sw	s0,296(sp)
800055ac:	13010413          	addi	s0,sp,304
800055b0:	eca42e23          	sw	a0,-292(s0)
800055b4:	00b42223          	sw	a1,4(s0)
800055b8:	00c42423          	sw	a2,8(s0)
800055bc:	00d42623          	sw	a3,12(s0)
800055c0:	00e42823          	sw	a4,16(s0)
800055c4:	00f42a23          	sw	a5,20(s0)
800055c8:	01042c23          	sw	a6,24(s0)
800055cc:	01142e23          	sw	a7,28(s0)
    // 首先在用户空间格式化字符串
    char buffer[256];  // 预先分配足够的缓冲区
    va_list args;
    va_start(args, format);
800055d0:	02040793          	addi	a5,s0,32
800055d4:	ecf42c23          	sw	a5,-296(s0)
800055d8:	ed842783          	lw	a5,-296(s0)
800055dc:	fe478793          	addi	a5,a5,-28
800055e0:	eef42223          	sw	a5,-284(s0)
    
    // 在用户空间完成格式化
    int len = _vsprintf(buffer, format, args);
800055e4:	ee442703          	lw	a4,-284(s0)
800055e8:	ee840793          	addi	a5,s0,-280
800055ec:	00070613          	mv	a2,a4
800055f0:	edc42583          	lw	a1,-292(s0)
800055f4:	00078513          	mv	a0,a5
800055f8:	93dff0ef          	jal	ra,80004f34 <_vsprintf>
800055fc:	fea42623          	sw	a0,-20(s0)
    va_end(args);
    
    // 然后调用系统调用只传递格式化后的字符串
    int ret;
    asm volatile(
80005600:	ee840793          	addi	a5,s0,-280
80005604:	00800893          	li	a7,8
80005608:	00078513          	mv	a0,a5
8000560c:	00000073          	ecall
80005610:	00050793          	mv	a5,a0
80005614:	fef42423          	sw	a5,-24(s0)
        "mv %0, a0"
        : "=r"(ret)
        : "i"(SYS_uart_puts), "r"(buffer)  // 使用uart_puts替代printf
        : "a0", "a7");
    
    return len;
80005618:	fec42783          	lw	a5,-20(s0)
}
8000561c:	00078513          	mv	a0,a5
80005620:	12c12083          	lw	ra,300(sp)
80005624:	12812403          	lw	s0,296(sp)
80005628:	15010113          	addi	sp,sp,336
8000562c:	00008067          	ret

80005630 <u_uart_puts>:

// 添加一个简单的vsprintf实现或从printf.c借用

void u_uart_puts(char *s)
{
80005630:	fe010113          	addi	sp,sp,-32
80005634:	00812e23          	sw	s0,28(sp)
80005638:	02010413          	addi	s0,sp,32
8000563c:	fea42623          	sw	a0,-20(s0)
    asm volatile(
80005640:	fec42783          	lw	a5,-20(s0)
80005644:	00800893          	li	a7,8
80005648:	00078513          	mv	a0,a5
8000564c:	00000073          	ecall
        "mv a0, %0\n"
        "ecall"
        :
        : "r"(s), "i"(SYS_uart_puts)
        : "a0", "a7");
80005650:	00000013          	nop
80005654:	01c12403          	lw	s0,28(sp)
80005658:	02010113          	addi	sp,sp,32
8000565c:	00008067          	ret
